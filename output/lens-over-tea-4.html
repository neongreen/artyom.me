<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">

  <meta name="google-site-verification" content="y-gj-eNGiiocXI1nd6EPlywGEfhW90jeeFO__ePHvbg" />
  <meta name="generator" content="pandoc">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <link rel="icon" type="image/png" href="/ame256.png">
  <link rel="alternate" type="application/rss+xml" href="/feed.xml"
        title="RSS">
  <title>lens over tea #4: isomorphisms, some profunctors, lens families</title>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="/css.css?date=2019-06-21">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-154447441-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-154447441-1');
</script>

</head>

<body>

<div id="header">
  <a href="/">Artyom Kazak</a>
  <a href="/feed.xml"><img src="/feed-icon.svg" alt="feed"></a>
</div>

<div id="details" class="blue-links">
  <div class="badge">
    <i class="fas fa-envelope"></i>
    <a href="mailto:artyom@artyom.me">artyom@artyom.me</a>
  </div
  ><div class="badge">
    <i class="fab fa-telegram"></i>
    <a href="http://t.me/lightgreen">lightgreen</a>
  </div
  ><div class="badge">
    <i class="fab fa-github"></i>
    <a href="http://github.com/neongreen">neongreen</a>
  </div

  ><div class="badge">
    Founder of <a href="https://aelve.com">Aelve</a>
  </div
  ><div class="badge">
    Co-founder of <a href="https://monadfix.io">Monadfix</a>
  </div

  ><div class="badge">
    Living in Moscow (come hang out!)
  </div>
</div>

<div id="main">



<div id="series">
      <a href="/lens-over-tea-3">&lt;&lt;&lt;</a>

  <a href="/#lens-over-tea">“lens over tea”</a>

      <a href="/lens-over-tea-5">&gt;&gt;&gt;</a>
  </div>


<article>
<h1 class="title">lens over tea #4: isomorphisms, some profunctors, lens families</h1>

<p>...as well as human sacrifice, dogs and cats living together, mass hysteria— ahem. There'll be prisms in the next post, but first we'll have to understand isomorphisms, because isomorphisms are easier and prisms kinda follow from isomorphisms.</p>
<p>Also:</p>
<ul>
<li><p>I'm tempted to ditch prisms and spend several days figuring out pure profunctor lenses instead (yes I'll explain what it means in this very post). Apparently currently knowledge of profunctor lenses is being passed orally on #haskell-lens and nowhere else (not counting <a href="http://r6research.livejournal.com/27476.html">this post</a> which isn't much more than a bunch of functions and types), and I hate the fact that there exist things which I can't learn without having to talk to someone else.</p></li>
<li><p>Thanks to ion on #haskell-lens for explaining things and making it click for me (primarily by showing me <a href="http://hackage.haskell.org/package/tagged/docs/Data-Tagged.html#t:Tagged"><code>Tagged</code></a> and explaining what <a href="http://hackage.haskell.org/package/profunctors/docs/Data-Profunctor.html#t:Choice"><code>Choice</code></a> is about). (This doesn't contradict the previous point – I'm still annoyed that to figure out prisms I had to talk to someone instead of, say, just consulting lens docs.)</p></li>
<li><p>I wonder how much upvotes will this part get, because on one hand the trend is rather bad (<a href="https://reddit.com/r/haskell/comments/2igp1v/lens_over_tea_part_1_lenses_101_traversals_101">62</a>–<a href="https://reddit.com/r/haskell/comments/2zg3fm/lens_over_tea_2_composition_laws">25</a>–<a href="https://reddit.com/r/haskell/comments/366pb3/lens_over_tea_3_folds">18</a>), but on the other hand this one has a more interesting-sounding title (I think?), so... we'll see. Yeah, I'm a sucker for upvotes.</p></li>
<li><p>Here's a <a href="/cat.webm">cat video</a> for you (watch with sound).</p></li>
</ul>
<h1 id="lens-families">Lens families</h1>
<p>There's a thing about polymorphic lenses which I haven't told you before because I didn't know about it.</p>
<p>Here's a polymorphic lens:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Lens</span> s t a b</code></pre></div>
<p>We know the following about such lenses:</p>
<ul>
<li><code>a</code> is a part of <code>s</code></li>
<li><code>b</code> is a part of <code>t</code></li>
<li>when you replace <code>a</code> in <code>s</code> with <code>b</code>, its type changes to <code>t</code></li>
</ul>
<p>(Just in case: “<code>a</code> is a part of <code>s</code>” doesn't necessarily mean that <code>s</code> looks like <code>Maybe a</code> or something else of the shape <code>g a</code>. It can perfectly be <code>(a, b)</code>, for instance, which can't be represented as a <code>g a</code> because Haskell lacks type-level lambdas (for the same reason you wouldn't be able to e.g. <a href="http://stackoverflow.com/questions/4812633/making-a-a-a-functor">make <code>(a, a)</code> a functor</a>). Moreover, there are lenses like <a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#v:united"><code>united</code></a> (of type <code>Lens' s ()</code>), which work for any <code>s</code>, no matter whether <code>()</code> is contained in <code>s</code> as a type parameter or not. So, “<code>a</code> is a part of <code>s</code>” should be understood as something conceptual and not literal.)</p>
<p>This intuitive understanding of polymorphic lenses is kinda formalised in <a href="http://comonad.com/reader/2012/mirrored-lenses/">this post</a>:</p>
<blockquote>
<p>So, why do I use the term “lens family” rather than “polymorphic lens”?</p>
<p>In order for the lens laws to hold, the 4 types parameterizing our lens family must be interrelated.</p>
<p>In particular you need to be able to put back (with <code>.~</code>) what you get out of the lens (with <code>^.</code>) and put multiple times.</p>
<p>This effectively constrains the space of possible legal lens families to those where there exists an index kind <code>i</code>, and two type families <code>outer :: i -&gt; *</code>, and <code>inner :: i -&gt; *</code>. If this were a viable type signature, then each lens family would actually have 2 parameters, yielding something like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- pseudo-Haskell</span>
<span class="kw">type</span> <span class="dt">LensFamily</span> outer inner <span class="fu">=</span>
  forall a b<span class="fu">.</span> <span class="dt">Lens</span> (outer a) (outer b) (inner a) (inner b)</code></pre></div>
</blockquote>
<p>This <code>forall a b</code> there implies that you should be able to swap pairs of types and nothing should change. See for yourself:</p>
<ul>
<li><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">_1<span class="ot"> ::</span> <span class="dt">Lens</span> (a, x) (b, x) a b
_1<span class="ot"> ::</span> <span class="dt">Lens</span> (b, x) (a, x) b a</code></pre></div></li>
<li><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">_<span class="dt">Left</span><span class="ot"> ::</span> <span class="dt">Prism</span> (<span class="dt">Either</span> a c) (<span class="dt">Either</span> b c) a b
_<span class="dt">Left</span><span class="ot"> ::</span> <span class="dt">Prism</span> (<span class="dt">Either</span> b c) (<span class="dt">Either</span> a c) b a</code></pre></div></li>
<li><div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">traversed ::</span> <span class="dt">Traversable</span> f <span class="ot">=&gt;</span> <span class="dt">Traversal</span> (f a) (f b) a b
<span class="ot">traversed ::</span> <span class="dt">Traversable</span> f <span class="ot">=&gt;</span> <span class="dt">Traversal</span> (f b) (f a) b a</code></pre></div></li>
</ul>
<p>In each pair, both types are <em>completely the same</em> because the only thing that's different is variable names, and renaming a type variable doesn't change the type.</p>
<p>If you have a weird lens like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Lens</span> [<span class="dt">Int</span>] [<span class="dt">Bool</span>] (<span class="dt">Maybe</span> <span class="dt">Char</span>) <span class="dt">String</span></code></pre></div>
<p>it'll never satisfy any lens laws, because they won't even typecheck (like, “you get what you put in”, yeah, except that you get <code>Maybe Char</code> and you put in <code>String</code> and they don't even <em>have</em> equality defined on them).</p>
<p>I'm not sure whether such lenses can ever be useful – the inner/outer law only restricts your setter, not your getter, so you'd only need to throw it away if you needed a weirder setter— I'll just make up an example, y'know.</p>
<p>Let's say you have strict <code>Text</code> and you want to simultaneously convert it to lazy <code>Text</code> and modify some characters:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.Text</span> <span class="kw">as</span> <span class="dt">Strict</span>
<span class="kw">import qualified</span> <span class="dt">Data.Text.Lazy</span> <span class="kw">as</span> <span class="dt">Lazy</span>

<span class="ot">strictToLazy ::</span> <span class="dt">Traversal</span> <span class="dt">Strict.Text</span> <span class="dt">Lazy.Text</span> <span class="dt">Char</span> <span class="dt">Char</span></code></pre></div>
<p>It looks like “simultaneously convert and modify” is this traversal's primary purpose. Why would you want to use it as a getter, then? You would use <code>each</code> as a generic getter/setter, and you would only use <code>strictToLazy</code> when you actually want to do this convert-and-modify thing, and then <code>strictToLazy</code> can be a setter instead.</p>
<p>But actually, I don't know. Let's move on to isomorphisms.</p>
<h1 id="iso"><code>Iso</code></h1>
<p>(Isos are defined in <a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html"><code>Control.Lens.Iso</code></a>.)</p>
<p>“Iso” is a shortening of “isomorphism”; an <code>Iso' s a</code>:</p>
<ul>
<li>is a lens which lets you access <code>a</code> in <code>s</code></li>
<li>is a lens which lets you access <code>s</code> in <code>a</code> (when inverted)</li>
<li>is isomorphic to <code>(s -&gt; a, a -&gt; s)</code></li>
</ul>
<p>So, if you have an <code>Iso' s a</code>, it means that you can convert between <code>s</code> and <code>a</code> without losing any information.</p>
<p>An <code>Iso s t a b</code> is a generalisation that also lets you change the types:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Iso</span> s t a b <span class="fu">~</span> (s <span class="ot">-&gt;</span> a, b <span class="ot">-&gt;</span> t)

over<span class="ot"> someIso        ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> t)
over (from someIso)<span class="ot"> ::</span> (t <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> a)
view<span class="ot"> someIso        ::</span> s <span class="ot">-&gt;</span> a
view (from someIso)<span class="ot"> ::</span> b <span class="ot">-&gt;</span> t</code></pre></div>
<p>And if you assume that the iso follows the inner/outer law and types can be safely swapped:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">over<span class="ot"> someIso        ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> t)
over (from someIso)<span class="ot"> ::</span> (s <span class="ot">-&gt;</span> t) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b)
view<span class="ot"> someIso        ::</span> s <span class="ot">-&gt;</span> a
view (from someIso)<span class="ot"> ::</span> a <span class="ot">-&gt;</span> s</code></pre></div>
<p>Now, as an example, let's take <a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:enum"><code>enum</code></a>. Previously you could've said it was a lens to “access” the value corresponding to a number:</p>
<div class="sourceCode"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="dv">88</span> <span class="fu">^.</span><span class="ot"> enum ::</span> <span class="dt">Char</span>
<span class="ch">&#39;X&#39;</span>

<span class="fu">&gt;</span> <span class="dv">88</span> <span class="fu">&amp;</span> enum <span class="fu">%~</span> toLower
<span class="dv">120</span>

<span class="fu">&gt;</span> fromEnum <span class="ch">&#39;x&#39;</span>
<span class="dv">120</span></code></pre></div>
<p>However, you can also use it to convert things in the other direction:</p>
<div class="sourceCode"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="dv">0</span> <span class="fu">&amp;</span> enum <span class="fu">.~</span> <span class="ch">&#39;x&#39;</span>
<span class="dv">120</span></code></pre></div>
<p>We were able to do it because we could create 0 out of thin air. In fact, we could even use <code>undefined</code> and <code>enum</code> wouldn't care:</p>
<div class="sourceCode"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span class="fu">&gt;</span> undefined <span class="fu">&amp;</span> enum <span class="fu">.~</span> <span class="ch">&#39;x&#39;</span>
<span class="dv">120</span></code></pre></div>
<p><code>Iso</code> generalises this notion of <em>lenses that don't care</em>.</p>
<h2 id="an-obvious-approach">An obvious approach</h2>
<p>If we want isos to work in both directions, we just need some type of “bidirectional function” which could work in either direction. Then constructing and inverting isos would be trivial:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Iso</span> s t a b <span class="fu">=</span>
  forall f<span class="fu">.</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">&lt;-</span><span class="fu">&gt;</span> (s <span class="ot">-&gt;</span> f t)</code></pre></div>
<p>In Haskell, when you want something to be several things at once, you define a class (<code>1</code> can be both <code>Int</code> and <code>Double</code> thanks to <code>Num</code>, <a href="http://hackage.haskell.org/package/base/docs/Control-Applicative.html#v:empty"><code>empty</code></a> can be both <code>[]</code> and <code>Nothing</code> thanks to <a href="http://hackage.haskell.org/package/base/docs/Control-Applicative.html#t:Alternative"><code>Alternative</code></a>, etc). So, let's create a class for bidirectional functions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Isomorphic</span> k <span class="kw">where</span>
<span class="ot">  isomorphic ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> k a b</code></pre></div>
<p>Now, if <code>-&gt;</code> is an instance of <code>Isomorphic</code>, then functions created with <code>isomorphic</code> would be usable as ordinary functions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Isomorphic</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span>
  <span class="co">-- we just don&#39;t need the other direction</span>
  isomorphic f _ <span class="fu">=</span> f</code></pre></div>
<p>You might think that now we would write an instance for <code>&lt;-</code> (well, <code>&lt;-</code> doesn't exist, so we'd have to write an instance for <a href="http://hackage.haskell.org/package/contravariant/docs/Data-Functor-Contravariant.html#v:Op"><code>Op</code></a> really, but still). But we won't – there's really no reason to bother with <code>&lt;-</code> when we can just store <em>both</em> directions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Isomorphism</span> a b <span class="fu">=</span> <span class="dt">Isomorphism</span> (a <span class="ot">-&gt;</span> b) (b <span class="ot">-&gt;</span> a)

<span class="kw">instance</span> <span class="dt">Isomorphic</span> <span class="dt">Isomorphism</span> <span class="kw">where</span>
  isomorphic <span class="fu">=</span> <span class="dt">Isomorphism</span></code></pre></div>
<p>With <code>Isomorphism</code>, it's much easier to write a function that would reverse an iso:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- from :: Isomorphism a b -&gt; Isomorphism b a</span>
<span class="co">-- from :: Isomorphism a b -&gt; (b -&gt; a)</span>
<span class="ot">from ::</span> <span class="dt">Isomorphic</span> k <span class="ot">=&gt;</span> <span class="dt">Isomorphism</span> a b <span class="ot">-&gt;</span> k b a
from (<span class="dt">Isomorphism</span> a b) <span class="fu">=</span> isomorphic b a</code></pre></div>
<p>Finally, we make <code>Iso</code> itself a bidirectional function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Iso</span> s t a b <span class="fu">=</span>
  forall k f<span class="fu">.</span> (<span class="dt">Isomorphic</span> k, <span class="dt">Functor</span> f) <span class="ot">=&gt;</span>
  k (a <span class="ot">-&gt;</span> f b) (s <span class="ot">-&gt;</span> f t)</code></pre></div>
<p>And you can create an iso from functions the easy way – just make 2 lenses going in opposite directions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">isos ::</span> (s <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> s)      <span class="co">-- s &lt;-&gt; a</span>
     <span class="ot">-&gt;</span> (t <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> t)      <span class="co">-- t &lt;-&gt; b</span>
     <span class="ot">-&gt;</span> <span class="dt">Iso</span> s t a b
isos sa as tb bt <span class="fu">=</span> isomorphic
  (\afb s <span class="ot">-&gt;</span> bt <span class="fu">&lt;$&gt;</span> afb (sa s))   <span class="co">-- easy peasy</span>
  (\sft a <span class="ot">-&gt;</span> tb <span class="fu">&lt;$&gt;</span> sft (as a))   <span class="co">-- lemon squeezy</span></code></pre></div>
<p>That's all. Since <code>Iso</code> uses the <code>Isomorphic</code> class, it would return a function when we apply <code>^.</code> to it, and it would return a nice pair of functions when we want to invert it with <code>from</code>. This is <a href="http://hackage.haskell.org/package/lens-3.6/docs/Control-Lens-Iso.html">exactly how things were done</a> in lens 3.6. You have just learned a piece of ancient Haskell!</p>
<p>This approach has a flaw, however: if you compose isos with <code>.</code>, they'll turn into ordinary functions and the result will be an ordinary function as well (while it <em>could</em> still be an iso). We can preserve both directions by writing an instance of <a href="http://hackage.haskell.org/package/base/docs/Control-Category.html#t:Category"><code>Category</code></a> for <code>Isomorphism</code> and using the <code>.</code> from <code>Control.Category</code>, but then we could just use it for lenses themselves and forget about all the pains we took to make them composable with ordinary <code>.</code>.</p>
<p>(It also has another flaw: you need to give <code>isos</code> 4 functions, but you could do with just 2. Ugh, inelegant.)</p>
<h2 id="a-better-approach">A better approach</h2>
<p>If we want to do better, we can't really do anything with <code>-&gt;</code> between <code>(a -&gt; f b)</code> and <code>(s -&gt; f t)</code> – it'll be lost when we try to compose isos. We also won't achieve anything by placing constraints on <code>f</code>. What to do, what to do?</p>
<p>Well, there's only 1 thing left to meddle with – <code>-&gt;</code>s in parens. Let's meddle!</p>
<hr />
<blockquote>
<p>In fact, we could even use <code>undefined</code> and <code>enum</code> wouldn't care:</p>
<div class="sourceCode"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span class="fu">&gt;</span> undefined <span class="fu">&amp;</span> enum <span class="fu">.~</span> <span class="ch">&#39;x&#39;</span>
<span class="dv">120</span></code></pre></div>
<p><code>Iso</code> generalises this notion of <em>lenses that don't care</em>.</p>
</blockquote>
<p>First I want to explain why exactly it doesn't care. As you know, a lens is isomorphic to this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Lens</span> s t a b <span class="fu">~</span> (s <span class="ot">-&gt;</span> a, s <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t)</code></pre></div>
<p>Or:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Lens</span> s t a b <span class="fu">~</span> (s <span class="ot">-&gt;</span> a, (s, b) <span class="ot">-&gt;</span> t)</code></pre></div>
<p>We can be even more precise if you remember the “hole in the type” approach – a lens decomposes <code>s</code> into <code>(s/a, a)</code> (except that there's no <code>/</code> in Haskell, but whatever) (I wrote <code>s/a</code> instead of <code>s−a</code> because compound types are denoted with “×”, and “+” is for sum types like <code>Either</code> – if you want to know more about algebra of types, I recommend <a href="http://chris-taylor.github.io/blog/2013/02/10/the-algebra-of-algebraic-data-types/">this post</a>):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Lens</span> s t a b <span class="fu">~</span> (s <span class="ot">-&gt;</span> a, s<span class="fu">/</span>a×b <span class="ot">-&gt;</span> t)</code></pre></div>
<p>However, if we assume that <code>a</code> is isomorphic to <code>s</code>, there's <em>nothing left</em> for <code>s/a</code>, and it's reduced to <code>1</code> (or <code>()</code> in Haskell):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Iso</span> s t a b <span class="fu">~</span> (s <span class="ot">-&gt;</span> a, s<span class="fu">/</span>a×b <span class="ot">-&gt;</span> t)
<span class="dt">Iso</span> s t a b <span class="fu">~</span> (s <span class="ot">-&gt;</span> a,   <span class="dv">1</span>×b <span class="ot">-&gt;</span> t)
<span class="dt">Iso</span> s t a b <span class="fu">~</span> (s <span class="ot">-&gt;</span> a,     b <span class="ot">-&gt;</span> t)</code></pre></div>
<p>In other words, when you take a setter – <code>s -&gt; b -&gt; t</code> – -the part of <code>s</code> that it has to look at to produce the result- equals to <code>()</code>. Or in other other words, it doesn't have to look at <code>s</code> at all – which is why we can set it to <code>undefined</code> and nothing would happen (and which is why the reverse holds as well, and lenses which can be fed <code>undefined</code> are isomorphisms).</p>
<hr />
<p>Here's how we would've written <code>enum</code> if it was a lens:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">enum ::</span> <span class="dt">Enum</span> a <span class="ot">=&gt;</span> <span class="dt">Lens&#39;</span> <span class="dt">Int</span> a
enum f <span class="fu">=</span> \s <span class="ot">-&gt;</span> fromEnum <span class="fu">&lt;$&gt;</span> f (toEnum s)</code></pre></div>
<p>Now let's consider 2 cases – the first is when we use it to turn <code>s</code> into <code>a</code>, the second is when we use the iso to turn <code>b</code> into <code>t</code>. The definition we already have works well enough for the former case, but in the latter case <code>s</code> doesn't even exist:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">enum f <span class="fu">=</span> \_ <span class="ot">-&gt;</span> fromEnum <span class="fu">&lt;$&gt;</span> f <span class="fu">???</span></code></pre></div>
<p>Since <code>f</code> can't possibly get any input, it must be a constant function (and the result of <code>enum</code> is a constant function too). To be able to write safe isomorphisms, we need some way to <em>ensure</em> that <code>f</code> and the result of <code>enum</code> are constant functions – if we don't, how can we be sure that -the function that is the result of <code>enum</code>- won't look at its argument (of type <code>s</code>)?</p>
<p>A constant function of type <code>a -&gt; b</code> is isomorphic to <code>b</code>. We could create our own type for constant functions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE TypeOperators #-}</span>

<span class="co">-- We don&#39;t have to use “:-&gt;”, but it looks slighty better than something like</span>
<span class="co">-- “data ConstantFunc a b = ConstantFunc b” and I also wanted to show that</span>
<span class="co">-- this kind of thing is possible.</span>
<span class="kw">data</span> a <span class="fu">:-&gt;</span> b <span class="fu">=</span> <span class="dt">Always</span> b</code></pre></div>
<p>But there's already such a type, called <a href="http://hackage.haskell.org/package/tagged/docs/Data-Tagged.html#t:Tagged"><code>Tagged</code></a> (in the <a href="https://hackage.haskell.org/package/tagged">tagged</a> package):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Tagged</span> a b <span class="fu">=</span> <span class="dt">Tagged</span> {<span class="ot">unTagged ::</span> b}</code></pre></div>
<blockquote>
<p>A <code>Tagged a b</code> value is a value <code>b</code> with an attached phantom type <code>a</code>. This can be used in place of the more traditional but less safe idiom of passing in an undefined value with the type, because unlike an <code>(a -&gt; b)</code>, a <code>Tagged a b</code> can't try to use the argument <code>a</code> as a real value.</p>
</blockquote>
<p>With <code>Tagged</code>, the definition of <code>enum</code> looks as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">enum ::</span> <span class="dt">Enum</span> a <span class="ot">=&gt;</span> <span class="dt">Tagged</span> a (f a) <span class="ot">-&gt;</span> <span class="dt">Tagged</span> <span class="dt">Int</span> (f <span class="dt">Int</span>)
enum (<span class="dt">Tagged</span> fa) <span class="fu">=</span> <span class="dt">Tagged</span> (fromEnum <span class="fu">&lt;$&gt;</span> fa)</code></pre></div>
<p>However, we have to support ordinary functions too, because there are 2 use cases (<code>s -&gt; a</code> and <code>b -&gt; t</code>) – when we want <code>s -&gt; a</code>, we would give <code>enum</code> an ordinary function, and when we want <code>b -&gt; t</code>, we would give <code>enum</code> a constant function. So, the following 2 definitions must be somehow compatible:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">enum (<span class="dt">Tagged</span> fa) <span class="fu">=</span> <span class="dt">Tagged</span> (fromEnum <span class="fu">&lt;$&gt;</span> fa)
enum f <span class="fu">=</span> \s <span class="ot">-&gt;</span> fromEnum <span class="fu">&lt;$&gt;</span> f (toEnum s)</code></pre></div>
<p>Whenever a function can operate on 2 different types in Haskell, it probably means that we'd have to use a typeclass. So, if we want to be able to give <code>enum</code> either an ordinary function or a constant function, we can just create a typeclass for functions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">IsoFunction</span> p <span class="kw">where</span>
  <span class="fu">...</span>

<span class="kw">type</span> <span class="dt">Iso</span> s t a b <span class="fu">=</span>
  forall p f<span class="fu">.</span> (<span class="dt">Functor</span> f, <span class="dt">IsoFunction</span> p) <span class="ot">=&gt;</span>
  p a (f b) <span class="ot">-&gt;</span> p s (f t)</code></pre></div>
<p>But what methods should that typeclass have? To find out, we have to unify the definitions I gave above:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">enum (<span class="dt">Tagged</span> fa) <span class="fu">=</span> <span class="dt">Tagged</span> (fromEnum <span class="fu">&lt;$&gt;</span> a)
enum afb <span class="fu">=</span> \s <span class="ot">-&gt;</span> fromEnum <span class="fu">&lt;$&gt;</span> afb (toEnum s)</code></pre></div>
<p>Okay, let's start unifying. First of all, get rid of the lambda:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">enum (<span class="dt">Tagged</span> fa) <span class="fu">=</span> <span class="dt">Tagged</span> (fromEnum <span class="fu">&lt;$&gt;</span> fa)
enum f <span class="fu">=</span> fmap fromEnum <span class="fu">.</span> f <span class="fu">.</span> toEnum</code></pre></div>
<p>Then get rid of explicitly working with <code>Tagged</code> by noticing that:</p>
<ul>
<li><code>Tagged</code> is a functor</li>
<li>there's a function called <a href="http://hackage.haskell.org/package/tagged/docs/Data-Tagged.html#v:retag"><code>retag :: Tagged x a -&gt; Tagged y a</code></a> that can change the type of a constant function's “input” to anything</li>
</ul>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">enum fa <span class="fu">=</span> fmap fromEnum <span class="fu">&lt;$&gt;</span> retag fa
enum f <span class="fu">=</span> fmap fromEnum <span class="fu">.</span> f <span class="fu">.</span> toEnum</code></pre></div>
<p>Then, let's observe some parallels:</p>
<ul>
<li><p>In the case of the ordinary function, <code>fmap fromEnum .</code> changes its output; in the case of the constant function, <code>fmap fromEnum &lt;$&gt;</code> changes its output.</p></li>
<li><p>In the case of the ordinary function, <code>. toEnum</code> changes its input; in the case of the constant function, <code>retag</code> changes the type of its nonexistent input.</p></li>
</ul>
<p>Let's rewrite the functions again to make it more obvious:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">enum fa <span class="fu">=</span> (fmap fromEnum <span class="fu">&lt;$&gt;</span>) <span class="fu">$</span> retag      <span class="fu">$</span> fa
enum f  <span class="fu">=</span> (fmap fromEnum <span class="fu">.</span>)   <span class="fu">$</span> (<span class="fu">.</span> toEnum) <span class="fu">$</span> f</code></pre></div>
<p>In both cases we apply the same 2 operations: one that changes input, and another that changes output. Well, let's make them the methods of our typeclass:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">IsoFunction</span> p <span class="kw">where</span>
<span class="ot">  changeInput  ::</span> (s <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> p a b <span class="ot">-&gt;</span> p s b
<span class="ot">  changeOutput ::</span> (b <span class="ot">-&gt;</span> t) <span class="ot">-&gt;</span> p a b <span class="ot">-&gt;</span> p a t

<span class="kw">instance</span> <span class="dt">IsoFunction</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span>
  changeInput f <span class="fu">=</span> (<span class="fu">.</span> f)
  changeOutput f <span class="fu">=</span> (f <span class="fu">.</span>)

<span class="kw">instance</span> <span class="dt">IsoFunction</span> <span class="dt">Tagged</span> <span class="kw">where</span>
  changeInput _ <span class="fu">=</span> retag
  changeOutput f <span class="fu">=</span> fmap f</code></pre></div>
<p>(Note that <code>changeInput</code> has to take a function even in case of <code>Tagged</code> – otherwise we wouldn't be able to unify the definitions.)</p>
<p>Now we can define <code>enum</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">enum <span class="fu">=</span> changeInput toEnum <span class="fu">.</span> changeOutput (fmap fromEnum)</code></pre></div>
<p>And a generic <code>iso</code> function which would create an iso:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">iso ::</span> (s <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> t) <span class="ot">-&gt;</span> <span class="dt">Iso</span> s t a b
iso sa bt <span class="fu">=</span> changeInput sa <span class="fu">.</span> changeOutput (fmap bt)</code></pre></div>
<p>And since we know how to extract both <code>s -&gt; a</code> and <code>b -&gt; t</code> from an iso, we can define <code>from</code> (which inverts an iso):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- e.g. from :: Enum a =&gt; Iso&#39; Int a -&gt; Iso&#39; a Int</span>
<span class="ot">from ::</span> <span class="dt">Iso</span> s t a b <span class="ot">-&gt;</span> <span class="dt">Iso</span> b a t s
from i <span class="fu">=</span> iso bt sa
  <span class="kw">where</span>
    <span class="co">-- This uses the (-&gt;) instance:</span>
    <span class="co">--   Сonst   :: a -&gt; Const a b   or  (-&gt;) a (Const a b)</span>
    <span class="co">--   i Const :: s -&gt; Const a t   or  (-&gt;) s (Const a t)</span>
    sa s <span class="fu">=</span> getConst ((i <span class="dt">Const</span>) s)

    <span class="co">-- This uses the Tagged instance:</span>
    <span class="co">--   Tagged (Identity b)     :: Tagged a (Identity b)</span>
    <span class="co">--   i (Tagged (Identity b)) :: Tagged s (Identity t)</span>
    bt b <span class="fu">=</span> runIdentity <span class="fu">.</span> unTagged <span class="fu">$</span> i (<span class="dt">Tagged</span> (<span class="dt">Identity</span> b))</code></pre></div>
<h1 id="profunctors-and-pure-profunctor-lenses">Profunctors and pure profunctor lenses</h1>
<p>Now guess what? The <code>IsoFunction</code> class is actually called <a href="http://hackage.haskell.org/package/profunctors/docs/Data-Profunctor.html#t:Profunctor"><code>Profunctor</code></a>, and its methods <code>changeInput</code> and <code>changeOutput</code> are actually called <a href="http://hackage.haskell.org/package/profunctors/docs/Data-Profunctor.html#v:lmap"><code>lmap</code></a> and <a href="http://hackage.haskell.org/package/profunctors/docs/Data-Profunctor.html#v:rmap"><code>rmap</code></a>, and there's also a <a href="http://hackage.haskell.org/package/profunctors/docs/Data-Profunctor.html#v:dimap"><code>dimap</code></a> method which combines <code>lmap</code> and <code>rmap</code> and which I'm going to use from now on:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lmap ::</span> <span class="dt">Profunctor</span> p <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> p b c <span class="ot">-&gt;</span> p a c
<span class="ot">rmap ::</span> <span class="dt">Profunctor</span> p <span class="ot">=&gt;</span> (b <span class="ot">-&gt;</span> c) <span class="ot">-&gt;</span> p a b <span class="ot">-&gt;</span> p a c

<span class="ot">dimap ::</span> <span class="dt">Profunctor</span> p <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> p b c <span class="ot">-&gt;</span> p a d</code></pre></div>
<p>The point of profunctors is that if you're given a <code>p a b</code>, you can treat it as an opaque “black box”, some kind of relationship between <code>a</code> and <code>b</code> – you can add a filter to the black box which would modify its output, and you can add another filter which would modify its input, but you can't modify the black box itself in any way and you can't inspect the input in any way (because, after all, there might not even be any) or get any information from one filter to another (this bit might not be clear, but it'll be clear when I explain <a href="http://hackage.haskell.org/package/profunctors/docs/Data-Profunctor.html#t:Choice"><code>Choice</code></a> in the next post).</p>
<p>If you want examples of profunctors in the wild, <a href="https://ocharles.org.uk/blog/guest-posts/2013-12-22-24-days-of-hackage-profunctors.html">this 24 Days Of Hackage post</a> and <a href="https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/profunctors">this School Of Haskell post</a> give some – but (as with pretty much all abstractions!) what's useful about profunctors isn't that you can use <code>dimap</code> to operate on something that happens to be a profunctor, but that you can write functions which work on several profunctors. For instance, this is what lets functions in lens operate on both ordinary and indexed traversals— okay, okay, maybe there'll be indexed traversals in the post after the next post.</p>
<hr />
<p>You could've noticed a bit of asymmetry in the definition of <code>from</code> – we used a custom type (<code>Tagged a b</code>) as a function which ignores its input, but we used <code>a -&gt; Const a b</code> as a function that remembers its input and doesn't do anything else. Isn't there some custom type for that too?</p>
<p>How might such a type look?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Input</span> a b <span class="fu">=</span> <span class="fu">...</span></code></pre></div>
<p>Okay, maybe just take <code>a -&gt; Const a b</code> itself?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Input</span> a b <span class="fu">=</span> <span class="dt">Input</span> (a <span class="ot">-&gt;</span> <span class="dt">Const</span> a b)</code></pre></div>
<p>No, it won't work – when we go from <code>Input a b</code> to <code>Input s b</code>, the inner type will change to <code>s -&gt; Const s b</code>, but we want it to be <code>s -&gt; Const a b</code>. In other words, we want to create a black box which would store its <em>immediate</em> input and not the input of the <code>s -&gt; a</code> filter that would be put in front of the black box.</p>
<p>The next attempt is to have an <a href="https://wiki.haskell.org/Existential_type">existential type</a> – something like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Input</span> a b <span class="fu">=</span> <span class="dt">Input</span> (exists x<span class="fu">.</span> a <span class="ot">-&gt;</span> x)</code></pre></div>
<p>This way <em>we</em> choose <code>x</code>, and nobody else can do anything else with <code>x</code> since they don't know what <code>x</code> actually stands for.</p>
<p>Unfortunately, there's no <code>exists</code> in Haskell, and we can't fake it with <code>forall</code> like this</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Input</span> a b <span class="fu">=</span> forall x<span class="fu">.</span> <span class="dt">Input</span> (a <span class="ot">-&gt;</span> x)</code></pre></div>
<p>because once we embed anything into <code>Input</code>, we'll lose information about what <code>x</code> was and we won't be able to get it back. So, we can resort to a simpler trick – making <code>x</code> a separate parameter:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Input</span> x a b <span class="fu">=</span> <span class="dt">Input</span> (a <span class="ot">-&gt;</span> x)</code></pre></div>
<p>Or, if we stick to standard terminology, the <a href="http://hackage.haskell.org/package/profunctors/docs/Data-Profunctor.html#t:Forget"><code>Forget</code></a> type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">Forget</span> r a b <span class="fu">=</span> <span class="dt">Forget</span> {<span class="ot"> runForget ::</span> a <span class="ot">-&gt;</span> r }

<span class="kw">instance</span> <span class="dt">Profunctor</span> (<span class="dt">Forget</span> r) <span class="kw">where</span>
  dimap f _ (<span class="dt">Forget</span> k) <span class="fu">=</span> <span class="dt">Forget</span> (k <span class="fu">.</span> f)</code></pre></div>
<p>Now we can replace <code>Const</code> with <code>Forget id</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">from ::</span> <span class="dt">Iso</span> s t a b <span class="ot">-&gt;</span> <span class="dt">Iso</span> b a t s
from i <span class="fu">=</span> iso bt sa
  <span class="kw">where</span>
    sa s <span class="fu">=</span> runForget (i (<span class="dt">Forget</span><span class="ot"> id ::</span> <span class="dt">Forget</span> a a (<span class="dt">Identity</span> b))) s
    bt b <span class="fu">=</span> runIdentity <span class="fu">.</span> unTagged <span class="fu">$</span> i (<span class="dt">Tagged</span> (<span class="dt">Identity</span> b))</code></pre></div>
<p>(I had to give <code>Forget id</code> a type – involving <code>Identity</code> – because otherwise GHC doesn't know what functor to use and gives an “ambiguous type” error.)</p>
<hr />
<p>And now, enter the pure profunctor lenses territory: if we were able to use <code>Identity</code> in both cases, we don't really need a functor there <em>at all!</em></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Iso</span> s t a b <span class="fu">=</span> forall p<span class="fu">.</span> <span class="dt">Profunctor</span> p <span class="ot">=&gt;</span> p a b <span class="ot">-&gt;</span> p s t</code></pre></div>
<p>Everything suddenly becomes much simpler when cruft stripped away:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">iso ::</span> (s <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> t) <span class="ot">-&gt;</span> <span class="dt">Iso</span> s t a b
iso <span class="fu">=</span> dimap

<span class="ot">from ::</span> <span class="dt">Iso</span> s t a b <span class="ot">-&gt;</span> <span class="dt">Iso</span> b a t s
from i <span class="fu">=</span> iso bt sa
  <span class="kw">where</span>
    sa s <span class="fu">=</span> runForget (i (<span class="dt">Forget</span> id)) s
    bt b <span class="fu">=</span> unTagged (i (<span class="dt">Tagged</span> b))</code></pre></div>
<p>Of course, this was a pure profunctor iso, not a pure profunctor lens, and I don't want to touch pure profunctor lenses yet because I'm afraid of them:</p>
<blockquote>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">lens ::</span> (s <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t) <span class="ot">-&gt;</span> <span class="dt">Lens</span> s t a b
lens f g <span class="fu">=</span> dimap (f <span class="fu">&amp;&amp;&amp;</span> id) (uncurry <span class="fu">$</span> flip g) <span class="fu">.</span> first&#39;</code></pre></div>
</blockquote>
<p>Maybe later.</p>
<h1 id="another-derivation-of-iso">Another derivation of <code>Iso</code></h1>
<p>I wrote this section before learning about <code>Tagged</code>, and I think it's interesting if only because it's another path getting to the same solution – “well, even if I never thought up <em>that</em> approach, I still wouldn't be entirely lost”.</p>
<hr />
<p>Since an iso is defined by a pair of functions – <code>s -&gt; a</code> and <code>b -&gt; t</code> – we could try to hide those functions somewhere in the arrow. It's pretty much the same trick we used in the section about isos-as-bidirectional-functions – create a class, make functions an instance, make &lt;something else&gt; an instance:</p>
<ul>
<li><p>if we end up doing lens-y things with the iso, well, we won't need &lt;something else&gt; at all</p></li>
<li><p>if we end up doing something iso-y, we'll demand &lt;something else&gt; from the iso (or the composition of isos)</p></li>
</ul>
<p>The simplest thing I can think of is this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Hide</span> x a b <span class="fu">=</span> <span class="dt">Hide</span> x</code></pre></div>
<p>(<code>a</code> and <code>b</code> are phantom parameters – we need them to unify with the <code>-&gt;</code> type.)</p>
<p>Next we can make a class:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Hiding</span> x p <span class="kw">where</span>
<span class="ot">  hide ::</span> x <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> p a b</code></pre></div>
<p>We can't hide anything in <code>-&gt;</code>, so we just leave it intact:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Hiding</span> x (<span class="ot">-&gt;</span>) <span class="kw">where</span>
  hide _ f <span class="fu">=</span> f</code></pre></div>
<p>We can hide things in <code>Hide</code>, tho:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Hiding</span> x (<span class="dt">Hide</span> x) <span class="kw">where</span>
  hide x _ <span class="fu">=</span> <span class="dt">Hide</span> x</code></pre></div>
<p>(It's important to realise that neither <code>Hide</code> nor <code>-&gt;</code> contain both the function and &lt;whatever we're hiding&gt; – it's one or the other. The trick is that since the caller gets to choose <em>which</em> one it wants, in reality it's both.)</p>
<p>Finally, that's our new type for <code>Iso</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Iso</span> s t a b <span class="fu">=</span>
  forall p f<span class="fu">.</span> (<span class="dt">Hiding</span> (s <span class="ot">-&gt;</span> a, b <span class="ot">-&gt;</span> t) p, <span class="dt">Functor</span> f) <span class="ot">=&gt;</span>
  (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> p s (f t)</code></pre></div>
<p>We naively store the representation of the iso in the returned value:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">iso ::</span> (s <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> t) <span class="ot">-&gt;</span> <span class="dt">Iso</span> s t a b
iso sa bt afb <span class="fu">=</span> hide (sa, bt) (\s <span class="ot">-&gt;</span> bt <span class="fu">&lt;$&gt;</span> afb (sa s))</code></pre></div>
<p>And we can get it back by passing a dummy <code>a -&gt; f b</code>. How can you get one? For instance, you could just always return <code>Const ()</code> as <code>f b</code>, but let's use <a href="http://hackage.haskell.org/package/base/docs/Data-Proxy.html#t:Proxy"><code>Proxy</code></a> from <a href="http://hackage.haskell.org/package/base/docs/Data-Proxy.html"><code>Data.Proxy</code></a> instead because learning about new things is nice and because it's sort of standard. Here's the definition of <code>Proxy</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Proxy</span> t <span class="fu">=</span> <span class="dt">Proxy</span></code></pre></div>
<p>(It's often used to “pass a type” to a class method without having to write something like <code>undefined :: Int</code> – you can write <code>Proxy :: Proxy Int</code> instead.)</p>
<p>So, to reverse an iso, we extract a pair of functions from it, swap them around, and create a new iso:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">from i <span class="fu">=</span> iso bt sa
  <span class="kw">where</span> <span class="dt">Hide</span> (sa, bt) <span class="fu">=</span> i (const <span class="dt">Proxy</span>)</code></pre></div>
<p>Let's create a couple isos, too:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">bool_int ::</span> <span class="dt">Iso</span> <span class="dt">Bool</span> <span class="dt">Bool</span> <span class="dt">Int</span> <span class="dt">Int</span>
bool_int <span class="fu">=</span> iso fromEnum toEnum

<span class="ot">int_char ::</span> <span class="dt">Iso</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="dt">Char</span> <span class="dt">Char</span>
int_char <span class="fu">=</span> iso toEnum fromEnum</code></pre></div>
<hr />
<p>What's wrong with this approach? Well, nothing, apart from the fact that now our isos don't compose <em>at all:</em></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">bool_char ::</span> <span class="dt">Iso</span> <span class="dt">Bool</span> <span class="dt">Bool</span> <span class="dt">Char</span> <span class="dt">Char</span>
bool_char <span class="fu">=</span> bool_int<span class="fu">.</span>int_char</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell repl"><code class="sourceCode haskell">    <span class="dt">Could</span> not deduce (<span class="dt">Hiding</span> (<span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>, <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) p) …
      arising from a use <span class="kw">of</span> ‘bool_int’
    from the context (<span class="dt">Hiding</span> (<span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>, <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) p, <span class="dt">Functor</span> f)
      bound by the <span class="kw">type</span> signature for
<span class="ot">        bool_char ::</span> (<span class="dt">Hiding</span> (<span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Char</span>, <span class="dt">Char</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>) p, <span class="dt">Functor</span> f) <span class="ot">=&gt;</span>
                     (<span class="dt">Char</span> <span class="ot">-&gt;</span> f <span class="dt">Char</span>) <span class="ot">-&gt;</span> p <span class="dt">Bool</span> (f <span class="dt">Bool</span>)
    <span class="dt">In</span> the first argument <span class="kw">of</span> ‘(<span class="fu">.</span>)’, namely ‘bool_int’
    <span class="dt">In</span> the expression<span class="fu">:</span> bool_int <span class="fu">.</span> int_char
    <span class="dt">In</span> an equation for ‘bool_char’<span class="fu">:</span> bool_char <span class="fu">=</span> bool_int <span class="fu">.</span> int_char</code></pre></div>
<p>It's not that easy to understand the error message, so I'll just explain what went wrong:</p>
<ul>
<li><p>We are using <code>iso</code> to put iso's representation into, well, the iso itself.</p></li>
<li><p>We use <code>iso</code> twice, so there are 4 functions that end up embedded into our 2 isos. Those functions are of types <code>Bool -&gt; Int</code>, <code>Int -&gt; Bool</code>, <code>Int -&gt; Char</code>, and <code>Char -&gt; Int</code>.</p></li>
<li><p>The composition of our isos should have the type <code>Iso Bool Bool Char Char</code>. It means that it should have functions of type <code>Bool -&gt; Char</code> and <code>Char -&gt; Bool</code> embedded into it.</p></li>
<li><p>At no point we are actually doing <em>anything</em> with functions of such types. There's no way they could appear!</p></li>
</ul>
<p>In other words, we can't hold on indefinitely to once-embedded <code>s -&gt; a</code> and <code>b -&gt; t</code>, because they need to be updated when we're combining things – but currently our isos don't ever update anything.</p>
<hr />
<p>Let's take 2 isos: <code>isoSTAB</code> and <code>isoABXY</code>. (Letters are nicer to work with than <code>Int</code> and <code>Bool</code> and <code>Char</code>.)</p>
<p>When you compose them, you would get <code>isoSTXY</code> (just like with lenses).</p>
<p><code>isoABXY</code> can return:</p>
<ul>
<li><code>a -&gt; f b</code></li>
<li><code>Hide (a -&gt; x, y -&gt; b)</code></li>
</ul>
<p><code>isoSTAB</code> would have to turn:</p>
<ul>
<li><code>a -&gt; f b</code> into <code>s -&gt; f t</code></li>
<li><code>Hide (a -&gt; x, y -&gt; b)</code> into <code>Hide (s -&gt; x, y -&gt; t)</code> (because we need to get <code>isoSTXY</code> in the end)</li>
</ul>
<p>So, we need to unify this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(a <span class="ot">-&gt;</span> f b)            <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> f t)
<span class="dt">Hide</span> (a <span class="ot">-&gt;</span> x, y <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Hide</span> (s <span class="ot">-&gt;</span> x, y <span class="ot">-&gt;</span> t)</code></pre></div>
<p>First of all, we can give <code>Hide</code> a different type to make unification easier:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Hide</span> x y a b <span class="fu">=</span> <span class="dt">Hide</span> (a <span class="ot">-&gt;</span> x) (y <span class="ot">-&gt;</span> b)  <span class="co">-- same as Hide (a -&gt; x, y -&gt; b)</span></code></pre></div>
<p>Now it looks like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(a <span class="ot">-&gt;</span> f b)    <span class="ot">-&gt;</span>  (s <span class="ot">-&gt;</span> f t)
<span class="dt">Hide</span> x y a b  <span class="ot">-&gt;</span>  <span class="dt">Hide</span> x y s t</code></pre></div>
<p>Or like this, if we make <code>-&gt;</code> prefix:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="ot">-&gt;</span>) a (f b)  <span class="ot">-&gt;</span>  (<span class="ot">-&gt;</span>) s (f t)
<span class="dt">Hide</span> x y a b  <span class="ot">-&gt;</span>  <span class="dt">Hide</span> x y s t</code></pre></div>
<p>Now we have <code>f</code> getting in the way, so let's add it to <code>Hide</code>. It won't break anything, because if <code>f</code> is a functor <em>we</em> would be able to choose (and it is), we can always go like this:</p>
<ul>
<li><code>Hide x y a (f b)</code></li>
<li><code>Hide x y a (Identity b)</code></li>
<li><code>Hide x y a b</code></li>
</ul>
<p>So, what we have now is this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="ot">-&gt;</span>) a (f b)      <span class="ot">-&gt;</span>  (<span class="ot">-&gt;</span>) s (f t)
<span class="dt">Hide</span> x y a (f b)  <span class="ot">-&gt;</span>  <span class="dt">Hide</span> x y s (f t)</code></pre></div>
<p>Or:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">(<span class="ot">-&gt;</span>)       a (f b)  <span class="ot">-&gt;</span>  (<span class="ot">-&gt;</span>)       s (f t)
(<span class="dt">Hide</span> x y) a (f b)  <span class="ot">-&gt;</span>  (<span class="dt">Hide</span> x y) s (f t)</code></pre></div>
<p>[rubs hands]</p>
<p>Excellent.</p>
<hr />
<p>Next, let's think what we want to do with both these things— no, wait, we already know the answer:</p>
<blockquote>
<p><code>isoSTAB</code> would have to turn:</p>
<ul>
<li><code>a -&gt; f b</code> into <code>s -&gt; f t</code></li>
<li><code>Hide (a -&gt; x, y -&gt; b)</code> into <code>Hide (s -&gt; x, y -&gt; t)</code> (because we need to get <code>isoSTXY</code> in the end)</li>
</ul>
</blockquote>
<p>Except that with our new types...</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Hide</span> x y a b <span class="fu">=</span> <span class="dt">Hide</span> (a <span class="ot">-&gt;</span> x) (y <span class="ot">-&gt;</span> b)</code></pre></div>
<p>...it's a bit different. <code>isoSTAB</code> would have to turn:</p>
<ul>
<li><code>a -&gt; f b</code> into <code>s -&gt; f t</code></li>
<li><code>Hide x y a (f b)</code> into <code>Hide x y s (f t)</code></li>
</ul>
<p>Okay, at this point we have all pieces of the puzzle. We know exactly which 2 types <code>iso</code> has to be, and all that is left is writing a typeclass:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">MakeIso</span> p <span class="kw">where</span>
<span class="ot">  iso ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (s <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> t) <span class="ot">-&gt;</span> p a (f b) <span class="ot">-&gt;</span> p s (f t)</code></pre></div>
<p>(Exercise: write instances by yourself!)</p>
<hr />
<p>The instance for <code>-&gt;</code> is straightforward:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">MakeIso</span> (<span class="ot">-&gt;</span>) <span class="kw">where</span>
  iso sa bt afb <span class="fu">=</span> \s <span class="ot">-&gt;</span> bt <span class="fu">&lt;$&gt;</span> afb (sa s)</code></pre></div>
<p>I don't like how cryptic it looks, but since writing it amounts to Just Following The Types, if you don't understand it just write it by yourself.</p>
<p>The instance for <code>Hide</code>, too, is straightforward (and &lt;same advice applies&gt;):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">MakeIso</span> (<span class="dt">Hide</span> x y) <span class="kw">where</span>
  iso sa bt (<span class="dt">Hide</span> ax yfb) <span class="fu">=</span> <span class="dt">Hide</span> sx yft
    <span class="kw">where</span> sx  <span class="fu">=</span> \s <span class="ot">-&gt;</span> ax <span class="fu">$</span> sa s
          yft <span class="fu">=</span> \y <span class="ot">-&gt;</span> bt <span class="fu">&lt;$&gt;</span> yfb y</code></pre></div>
<p>For the sake of completeness, here's the new <code>Iso</code> type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Iso</span> s t a b <span class="fu">=</span>
  forall p f<span class="fu">.</span> (<span class="dt">MakeIso</span> p, <span class="dt">Functor</span> f) <span class="ot">=&gt;</span>
  p a (f b) <span class="ot">-&gt;</span> p s (f t)</code></pre></div>
<hr />
<p>We also need to write <code>from</code>, and to do that, we need to learn how to extract functions from an iso. Let's use reasoning to do it! (I mean, more reasoning reasoning than usual. Kinda. Whatever.)</p>
<p>We start with an <code>Iso</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">i ::</span> <span class="dt">Iso</span> s t a b</code></pre></div>
<p>Expand it using the definition of <code>Iso</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Iso</span> s t a b <span class="fu">=</span>
  forall p f<span class="fu">.</span> (<span class="dt">MakeIso</span> p, <span class="dt">Functor</span> f) <span class="ot">=&gt;</span>
  p a (f b) <span class="ot">-&gt;</span> p s (f t)

<span class="ot">i ::</span> (<span class="dt">MakeIso</span> p, <span class="dt">Functor</span> f) <span class="ot">=&gt;</span> p a (f b) <span class="ot">-&gt;</span> p s (f t)</code></pre></div>
<p>(I removed <code>forall p f</code> because it's not really needed there.)</p>
<p>Now, we actually know what we want to get – <code>Hide a b s (f t)</code>:</p>
<pre><code>p s (f t) = Hide a b s (f t)</code></pre>
<p>From it we can deduce:</p>
<pre><code>p = Hide a b</code></pre>
<p>And therefore:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">i ::</span> (<span class="dt">Functor</span> f) <span class="ot">=&gt;</span> <span class="dt">Hide</span> a b a (f b) <span class="ot">-&gt;</span> <span class="dt">Hide</span> a b s (f t)</code></pre></div>
<p>Also, since we can choose <code>f</code>, let's choose <code>Identity</code> because we can always strip it away:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">i ::</span> <span class="dt">Hide</span> a b a (<span class="dt">Identity</span> b) <span class="ot">-&gt;</span> <span class="dt">Hide</span> a b s (<span class="dt">Identity</span> t)</code></pre></div>
<p>We're going to get our <code>Hide a b s (Identity t)</code> if we can get <code>Hide a b a (Identity b)</code> from somewhere. Can we get it?</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Hide</span> a b a (<span class="dt">Identity</span> b) <span class="fu">=</span> <span class="dt">Hide</span> (a <span class="ot">-&gt;</span> a) (b <span class="ot">-&gt;</span> <span class="dt">Identity</span> b)</code></pre></div>
<p>Yep, seems easy enough – <code>Hide id Identity</code>. And once we have <code>s -&gt; Identity t</code>, we can combine it with <a href="http://hackage.haskell.org/package/base/docs/Data-Functor-Identity.html#v:runIdentity"><code>runIdentity</code></a> to get <code>s -&gt; t</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">from i <span class="fu">=</span> iso (runIdentity <span class="fu">.</span> bt) sa
  <span class="kw">where</span> <span class="dt">Hide</span> sa bt <span class="fu">=</span> i (<span class="dt">Hide</span> id <span class="dt">Identity</span>)</code></pre></div>
<hr />
<p>It's only left to notice that <code>MakeIso</code> is pretty much just like <code>Profunctor</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">MakeIso</span> p <span class="kw">where</span>
<span class="ot">  iso ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (s <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> t) <span class="ot">-&gt;</span> p a (f b) <span class="ot">-&gt;</span> p s (f t)

<span class="kw">class</span> <span class="dt">Profunctor</span> p <span class="kw">where</span>
<span class="ot">  dimap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> (c <span class="ot">-&gt;</span> d) <span class="ot">-&gt;</span> p b c <span class="ot">-&gt;</span> p a d</code></pre></div>
<p><code>Hide</code> can be easily made an instance:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Profunctor</span> (<span class="dt">Hide</span> x y) <span class="kw">where</span>
  dimap sa bt (<span class="dt">Hide</span> ax yb) <span class="fu">=</span> <span class="dt">Hide</span> sx yt
    <span class="kw">where</span> sx <span class="fu">=</span> ax <span class="fu">.</span> sa
          yt <span class="fu">=</span> bt <span class="fu">.</span> yb</code></pre></div>
<p>Then we can change the definitions of <code>Iso</code> and <code>iso</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Iso</span> s t a b <span class="fu">=</span>
  forall p f<span class="fu">.</span> (<span class="dt">Profunctor</span> p, <span class="dt">Functor</span> f) <span class="ot">=&gt;</span>
  p a (f b) <span class="ot">-&gt;</span> p s (f t)

<span class="ot">iso ::</span> (s <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (b <span class="ot">-&gt;</span> t) <span class="ot">-&gt;</span> <span class="dt">Iso</span> s t a b
iso sa bt <span class="fu">=</span> dimap sa (fmap bt) afb</code></pre></div>
<p>Rename <code>Hide</code> to <a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Internal-Iso.html#t:Exchange"><code>Exchange</code></a> (because that's how it's called in lens):</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Exchange</span> a b s t <span class="fu">=</span> <span class="dt">Exchange</span> (s <span class="ot">-&gt;</span> a) (b <span class="ot">-&gt;</span> t)</code></pre></div>
<p>Write an explicit type – <a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#t:AnIso"><code>AnIso</code></a> – for &lt;whatever <code>from</code> accepts&gt;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">AnIso</span> s t a b <span class="fu">=</span> <span class="dt">Exchange</span> a b a (<span class="dt">Identity</span> b) <span class="ot">-&gt;</span>
                     <span class="dt">Exchange</span> a b s (<span class="dt">Identity</span> t) </code></pre></div>
<p>This type can be used whenever we want to write a function which takes an <code>Iso</code>, because it's the “smallest” type that fully describes an iso. (By the way, <code>Lens</code> and <code>Traversal</code> have similar types associated with them – <a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Lens.html#t:ALens"><code>ALens</code></a> and <a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#t:ATraversal"><code>ATraversal</code></a> – but they're implemented using weird-sounding things like <code>Bazaar</code> and <code>Pretext</code> with very helpful descriptions like “a.k.a. indexed Cartesian store comonad, indexed Kleene store comonad, or an indexed <code>FunList</code>” and I don't want to touch them with a 10-foot pole. [sighs] I guess I'll have to sooner or later...)</p>
<hr />
<p>This approach has actually led us slightly further than the previous one – previously we needed <code>-&gt;</code> and <code>Tagged</code> to implement <code>from</code>, but now we can extract both the “getter” and the “setter” in 1 pass (using <code>Exchange</code>), and we also can write <code>AnIso</code> (which we couldn't do before because we needed the iso to be polymorphic to use it with both <code>-&gt;</code> and <code>Tagged</code>). However, we definitely could've invented <code>Exchange</code> without all the mess in this section, by noticing that:</p>
<ul>
<li><p>We can try to combine <code>Forget</code> and <code>Tagged</code> to get both thing we need in 1 pass:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">FT</span> r a b <span class="fu">=</span> <span class="dt">FT</span> (a <span class="ot">-&gt;</span> r) b</code></pre></div>
<p>and make it an instance of <code>Profunctor</code> and everything.</p></li>
<li><p>We can't, however, use <code>FT</code> to get both <code>s -&gt; a</code> and <code>b -&gt; t</code>, because currently we get <code>b -&gt; t</code> basically by feeding <code>b</code> to the iso and taking <code>t</code> from the result. So, with <code>FT</code> we can have this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">bsat ::</span> b <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> a, t)
bsat b <span class="fu">=</span> <span class="kw">let</span> <span class="fu">...</span> <span class="fu">=</span> i (<span class="dt">FT</span> id (<span class="dt">Identity</span> b)) <span class="kw">in</span> <span class="fu">...</span></code></pre></div>
<p>but we can't get <code>b -&gt; t</code> and <code>s -&gt; a</code> separately.</p></li>
<li><p>The trick is in using <code>exists x. x -&gt; b</code> instead of <code>b</code> as our type for “constant function” – they're equivalent:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">FT</span> r x a b <span class="fu">=</span> <span class="dt">FT</span> (a <span class="ot">-&gt;</span> r) (x <span class="ot">-&gt;</span> b)</code></pre></div>
<p>(and again we replace <code>exists</code> with the type-variable-outside trick).</p></li>
<li><p>And now <code>FT</code> is actually <code>Exchange</code> with a different name and type variables. Ha.</p></li>
</ul>
<h1 id="some-useful-isos">Some useful isos</h1>
<p><a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:strict"><code>strict</code></a> converts a lazy <code>Text</code> or <code>ByteString</code> to a strict one (and back):</p>
<div class="sourceCode"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span class="fu">&gt;</span> lazyTexts <span class="fu">&amp;</span> each<span class="fu">.</span>strict <span class="fu">%~</span> doSomethingWithStrictText</code></pre></div>
<p>(You can use <code>from strict</code> to go in the opposite direction, or you can use <a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:lazy"><code>lazy</code></a>.)</p>
<p><a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:reversed"><code>reversed</code></a> is an isomorphism between things and... well, reversed things:</p>
<div class="sourceCode"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="st">&quot;live&quot;</span> <span class="fu">^.</span> reversed
<span class="st">&quot;evil&quot;</span>

<span class="fu">&gt;</span> <span class="st">&quot;live&quot;</span> <span class="fu">&amp;</span> reversed <span class="fu">%~</span> (<span class="ch">&#39;d&#39;</span><span class="fu">:</span>)
<span class="st">&quot;lived&quot;</span></code></pre></div>
<p>(It has instances for many various containers, as well as <code>Text</code> and so on.)</p>
<p><a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:swapped"><code>swapped</code></a> swaps/unswaps sides of tuples or <code>Either</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span class="fu">&gt;</span> (<span class="dv">1</span>,<span class="dv">2</span>) <span class="fu">^.</span> swapped
(<span class="dv">2</span>,<span class="dv">1</span>)

<span class="fu">&gt;</span> <span class="dt">Left</span> <span class="st">&quot;hi&quot;</span> <span class="fu">^.</span> swapped
<span class="dt">Right</span> <span class="st">&quot;hi&quot;</span></code></pre></div>
<p><a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:non"><code>non</code></a> is an isomorphism for <code>Maybe a</code> that lets you assign some arbitrary value to <code>Nothing</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">non ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Iso&#39;</span> (<span class="dt">Maybe</span> a) a</code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="dt">Just</span> <span class="dv">185</span> <span class="fu">^.</span> non <span class="dv">0</span>
<span class="dv">185</span>

<span class="fu">&gt;</span> <span class="dt">Nothing</span> <span class="fu">^.</span> non <span class="dv">0</span>
<span class="dv">0</span></code></pre></div>
<p>It's more useful, however, when you're using it for setting/modifying – it combines the “modifying” step and the “checking we don't have any values we don't like” step:</p>
<div class="sourceCode"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span class="fu">&gt;</span> <span class="dt">Just</span> <span class="dv">185</span> <span class="fu">&amp;</span> non <span class="dv">0</span> <span class="fu">-~</span> <span class="dv">185</span>
<span class="dt">Nothing</span></code></pre></div>
<p>It's even more useful when you're working with maps and <a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-At.html#v:at"><code>at</code></a> and also nested maps and stuff, but I haven't talked about <code>at</code> yet and I don't want to do it <em>now</em>, so just read the examples in the docs for <a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Iso.html#v:non"><code>non</code></a> if you're interested.</p>
</article>


<div id="series">
      <a href="/lens-over-tea-3">&lt;&lt;&lt;</a>

  <a href="/#lens-over-tea">“lens over tea”</a>

      <a href="/lens-over-tea-5">&gt;&gt;&gt;</a>
  </div>

</div>

<div id="monadfix" class="blue-links">
  <h3>I'm doing software consulting!</h3>
  <p>
    Nowadays I'm running a functional programming consultancy at
    <a href="https://monadfix.io">Monadfix</a>. We have experts in Haskell,
    PureScript, Clojure, and Agda. We are looking for more clients and more
    consultants!
  </p>
</div>

<div id="disqus_thread"></div>
<script>
var disqus_config = function () {
this.page.url = "https://artyom.me/lens-over-tea-4";
this.page.identifier = "lens-over-tea-4";
};
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = '//artyomkazak.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

<div id="footer" class="blue-links">
<a href="https://github.com/neongreen/artyom.me/blob/master/posts/lens-over-tea-4.md">view source</a>—<a href="mailto:artyom@artyom.me?subject=Comment on lens-over-tea-4">comment by email</a>—<a href="/curiosity">curiosity killed the cat</a>
</div>

</div>

<script>
document.body.innerHTML = document.body.innerHTML.replace(/‾/g, "<span style='text-decoration: overline'> </span>");
</script>

</body>
</html>
