<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="google-site-verification" content="y-gj-eNGiiocXI1nd6EPlywGEfhW90jeeFO__ePHvbg" />
  <meta name="generator" content="pandoc">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <link rel="icon" type="image/png" href="/ame256.png">
  <link rel="alternate" type="application/rss+xml" href="/feed.xml"
        title="RSS">
  <title>lens over tea #1: lenses 101, traversals 101, and some implementation details</title>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <link rel="stylesheet" href="/css.css?date=2020-01-31">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-154447441-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-154447441-1');
</script>

</head>

<body>

<div id="header">
  <a href="/">Artyom Kazak</a>
  <a href="/feed.xml"><img src="/feed-icon.svg" alt="feed"></a>
</div>

<div id="details" class="blue-links">
  <div class="badge">
    <i class="fas fa-envelope"></i>
    <a href="mailto:artyom@artyom.me">artyom@artyom.me</a>
  </div
  ><div class="badge">
    <i class="fab fa-telegram"></i>
    <a href="https://telegram.me/lightgreen">lightgreen</a>
  </div
  ><div class="badge">
    <i class="fab fa-github"></i>
    <a href="https://github.com/neongreen">neongreen</a>
  </div

  ><div class="badge">
    Co-founder of <a href="https://monadfix.com">Monadfix</a>
  </div

  ><div class="badge">
    Living in Minsk (come hang out!)
  </div
  ><div class="badge">
    <a href="https://blog.artyom.me">Blog</a>
  </div
  ><div class="badge">
    <a href="https://getrevue.co/profile/artyom">Newsletter</a>
  </div>
</div>

<div id="main">



<div id="series">
      <span class="grey"><a href="/#lens-over-tea">&lt;&lt;&lt;</a></span>
  
  <a href="/#lens-over-tea">“lens over tea”</a>

      <a href="/lens-over-tea-2">&gt;&gt;&gt;</a>
  </div>


<article>
<h1 class="title">lens over tea #1: lenses 101, traversals 101, and some implementation details</h1>

<p>Okay, so I never could really understand how <a href="https://hackage.haskell.org/package/lens">lens</a> works. This is an attempt to understand lens as completely as possible, including the ideas behind it, the implementation, and the design choices. (A later update: it’s not that good for actually learning how to use lenses, and frankly should be fully rewritten, but I don’t have the time.)</p>
<p>There are already articles which explain how to <em>use</em> lenses and how to <em>make</em> basic lenses, but some things don’t seem to be explained well anywhere:</p>
<ul>
<li>zooming</li>
<li>prisms/isos</li>
<li>indexed stuff</li>
<li>implementation details</li>
<li>category theory “mumbo-jumbo”</li>
<li>performance</li>
</ul>
<p>(or they are explained but in such a way that an “ordinary person” can’t understand them). That’s why I decided to write a series of articles about lens. I hope I’ll learn something in the process, and maybe you will too (if I don’t completely suck at explaining stuff, that is).</p>
<p>Regarding implementation details: I spend perhaps too much time discussing those, so if you’re reading these posts just to learn how to use lenses, it might be a waste of time and I recommend you to look for another tutorial.</p>
<p>I’m not assuming that you’ve ever used lenses, or know category theory, or profunctors, or anything of the sort. I <em>am</em> assuming that you can use <code>Monoid</code>, <code>Functor</code>, <code>Applicative</code> and <code>Monad</code>, but nothing beyond that; if you don’t know these either, read</p>
<ul>
<li><a href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids">LYAH on functors and monoids</a></li>
<li><a href="http://learnyouahaskell.com/a-fistful-of-monads">LYAH on monads</a></li>
<li>a <a href="https://www.fpcomplete.com/school/advanced-haskell/functors-applicative-functors-and-monads">School of Haskell tutorial</a></li>
<li>an <a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">explanation with pictures</a> if you like pictures (I don’t, but maybe you do, who knows).</li>
</ul>
<p>To be honest, tho, you probably shouldn’t be touching lens until you know those things – unless you only need lenses to do record updates and other simple stuff, in which case read <a href="http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html">Gabriel Gonzales’s lens tutorial</a> and the <a href="https://en.wikibooks.org/wiki/Haskell/Lenses_and_functional_references">Wikibook chapter on lenses</a> (which is actually a good lenses tutorial in general).</p>
<h1 id="disclaimers">Disclaimers</h1>
<p>I tried to write in such a way that I myself (the <em>past</em> self, I mean) would’ve been able to understand what I’ve written – which means explaining everything many times. When something is explained only once, the reader has to think while reading, and there’s nothing worse than having to think while reading.</p>
<p>…Fine, maybe there was a bit of sarcasm in the last sentence, but I definitely know that there is at least 1 person (yeah, me) who only reads articles while drinking tea or waiting for something to compile. So, in order for me to learn anything, there <em>has</em> to be an article about it somewhere which can be read while drinking tea – and this is an article about lenses which can be read while drinking tea.</p>
<p><strong>Disclaimer #1:</strong> you might need more than 1 cup.</p>
<p><strong>Disclaimer #2:</strong> as usual with my posts, I’ve no idea what I’m writing about, so, if anybody says I’m wrong about something, I’m most likely indeed wrong about it.</p>
<p><strong>Disclaimer #3:</strong> this post is an exploration more than an explanation, so don’t expect the text to be structured the way normal blog posts are. If I knew how to structure it all in such a way that it wouldn’t be a tangled braindump, I would’ve done that.</p>
<hr />
<p>Okay, enough of <del>chit-chat</del> important and appropriate disclaimers. Here goes.</p>
<h1 id="lenses-101">Lenses 101</h1>
<p>A lens allows us to get some value from a Big Value, and to update some value in the Big Value. (Admittedly, it’s a <em>slightly</em> simplistic view, but it’ll do for now.) E.g. <code>(1, True)</code> is a “big” value which contains <code>1</code> and <code>True</code>. Here’s how to get <code>1</code> from <code>(1, True)</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1"></a><span class="op">&gt;</span> <span class="fu">fst</span> (<span class="dv">1</span>, <span class="dt">True</span>)</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="dv">1</span></span></code></pre></div>
<p>However, <code>fst</code> is only a <em>getter</em> – it doesn’t allow updating the value. Moreover, there’s no <code>setFst</code> function in Prelude, which means that changing <code>1</code> to <code>8</code> in <code>(1, True)</code> is a huge, giant, enormous pain:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1"></a><span class="op">&gt;</span> (<span class="dv">8</span>, <span class="fu">snd</span> (<span class="dv">1</span>, <span class="dt">True</span>))</span>
<span id="cb2-2"><a href="#cb2-2"></a>(<span class="dv">8</span>, <span class="dt">True</span>)</span></code></pre></div>
<p>It might not <em>seem</em> like “huge, giant, enormous pain”, but it’s still like, say, a small papercut – and a thousand papercuts <em>are</em> a pain. Moreover, for me even one papercut is a pain… Okay, fine, sorry for sharing my stupid phobia of paper cuts with you, but please at least agree that -having separate functions to get a value and set a value- isn’t all that nice. Can we do better?</p>
<h2 id="getter-setter-lens">Getter + setter = lens</h2>
<p>One solution is to combine a getter and a setter in a single structure:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">data</span> <span class="dt">Lens</span> s a <span class="ot">=</span> <span class="dt">Lens</span></span>
<span id="cb3-2"><a href="#cb3-2"></a>  {<span class="ot"> getter ::</span> s <span class="ot">-&gt;</span> a</span>
<span id="cb3-3"><a href="#cb3-3"></a>  ,<span class="ot"> setter ::</span> a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> s }</span></code></pre></div>
<p>While we’re at it, let’s write our first lens – the <code>ix</code> lens, which accesses the i-th element of a list.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1"></a><span class="ot">setIth ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb4-2"><a href="#cb4-2"></a>setIth <span class="fu">index</span> new list</span>
<span id="cb4-3"><a href="#cb4-3"></a>  <span class="op">|</span> <span class="fu">index</span> <span class="op">&lt;</span> <span class="dv">0</span>        <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;setIth: negative index&quot;</span></span>
<span id="cb4-4"><a href="#cb4-4"></a>  <span class="op">|</span> <span class="fu">null</span> list        <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;setIth: index too large&quot;</span></span>
<span id="cb4-5"><a href="#cb4-5"></a>  <span class="op">|</span> old<span class="op">:</span>rest <span class="ot">&lt;-</span> list <span class="ot">=</span> <span class="kw">if</span> <span class="fu">index</span> <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>                         <span class="kw">then</span> new <span class="op">:</span> rest</span>
<span id="cb4-7"><a href="#cb4-7"></a>                         <span class="kw">else</span> old <span class="op">:</span> setIth (<span class="fu">index</span><span class="op">-</span><span class="dv">1</span>) new rest</span>
<span id="cb4-8"><a href="#cb4-8"></a></span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="ot">ix ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Lens</span> [a] a</span>
<span id="cb4-10"><a href="#cb4-10"></a>ix i <span class="ot">=</span> <span class="dt">Lens</span> { getter <span class="ot">=</span> (<span class="op">!!</span> i)</span>
<span id="cb4-11"><a href="#cb4-11"></a>            , setter <span class="ot">=</span> setIth i }</span></code></pre></div>
<p>I don’t like this approach either. Think about it: to increment the 1000th element of a list, we have to find it using <code>getter</code>, then increment it, then <code>setter</code> would have to find it <em>again</em> in order to set the new value. It’s okay when we’re talking about tuples or <code>Map</code>s, but when I think about having to traverse a long list twice in order to do something with a value, I feel slightly bad.</p>
<p>The fix is easy – it’s enough to replace <code>setter :: a -&gt; s -&gt; s</code> with <code>modifier :: (a -&gt; a) -&gt; s -&gt; s</code>. However, I have another objection: in order to get to the value, <code>modifier</code> <em>still</em> has to reimplement the functionality of <code>getter</code>. Code duplication is wrong. Can we do better?</p>
<h2 id="removing-the-getter">Removing the getter</h2>
<p>Hm… what about making <code>modifier</code> return the value before the modification? Then <code>getter</code> isn’t even needed:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1"></a><span class="kw">import</span> <span class="dt">Data.Bifunctor</span></span>
<span id="cb5-2"><a href="#cb5-2"></a></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="kw">type</span> <span class="dt">Lens</span> s a <span class="ot">=</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (a, s)</span>
<span id="cb5-4"><a href="#cb5-4"></a></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="co">-- ix :: Int -&gt; (a -&gt; a) -&gt; [a] -&gt; (a, [a])</span></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="ot">ix ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Lens</span> [a] a</span>
<span id="cb5-7"><a href="#cb5-7"></a>ix <span class="fu">index</span> f list</span>
<span id="cb5-8"><a href="#cb5-8"></a>  <span class="op">|</span> <span class="fu">index</span> <span class="op">&lt;</span> <span class="dv">0</span>        <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;ix: negative index&quot;</span></span>
<span id="cb5-9"><a href="#cb5-9"></a>  <span class="op">|</span> <span class="fu">null</span> list        <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;ix: index too large&quot;</span></span>
<span id="cb5-10"><a href="#cb5-10"></a>  <span class="op">|</span> old<span class="op">:</span>rest <span class="ot">&lt;-</span> list <span class="ot">=</span> <span class="kw">if</span> <span class="fu">index</span> <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb5-11"><a href="#cb5-11"></a>                         <span class="kw">then</span> (old, f old <span class="op">:</span> rest)</span>
<span id="cb5-12"><a href="#cb5-12"></a>                         <span class="kw">else</span> second (old<span class="op">:</span>) <span class="op">$</span> ix (<span class="fu">index</span><span class="op">-</span><span class="dv">1</span>) f rest</span></code></pre></div>
<ul>
<li><p><a href="http://hackage.haskell.org/package/base/docs/Data-Bifunctor.html#v:second"><code>second</code></a> is a function from <code>Data.Bifunctor</code>, which can be used to apply a function to the second element of a tuple (among other things):</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1"></a><span class="op">&gt;</span> second (<span class="st">&quot;second &quot;</span> <span class="op">++</span>) (<span class="dt">True</span>, <span class="st">&quot;element&quot;</span>)</span>
<span id="cb6-2"><a href="#cb6-2"></a>(<span class="dt">True</span>, <span class="st">&quot;second element&quot;</span>)</span></code></pre></div>
<p>So, the line</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1"></a>second (old<span class="op">:</span>) <span class="op">$</span> ix (<span class="fu">index</span><span class="op">-</span><span class="dv">1</span>) f rest</span></code></pre></div>
<p>is the same as</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">let</span> (x&#39;, s&#39;) <span class="ot">=</span> ix (<span class="fu">index</span><span class="op">-</span><span class="dv">1</span>) f rest</span>
<span id="cb8-2"><a href="#cb8-2"></a><span class="kw">in</span>  (x&#39;, old <span class="op">:</span> s&#39;)</span></code></pre></div></li>
<li><p>We could use <code>second</code> from <code>Control.Arrow</code> instead, but I chose <code>Data.Bifunctor</code> because bifunctors are much easier to understand than arrows.</p></li>
<li><p>In a nutshell, a bifunctor is merely a functor with 2 parameters instead of 1. <code>Either</code> and <code>(,)</code> are both bifunctors (which means that you can use <code>first</code> and <code>second</code> on things like <code>Either a b</code> or <code>(a, b)</code>).</p></li>
<li><p>If you’re getting bored, here’s a question for you: is <code>(-&gt;)</code> a bifunctor?</p></li>
<li><p>(Yeah, we could use <code>let</code> and avoid scary bifunctors entirely, but I wanted to have an excuse to introduce them. <em>Or</em> we could use <code>fmap</code> since it’s the same as <code>second</code> for tuples – but I don’t like using <code>fmap</code> as a sort of a magic wand. It’s better to state your intentions explicitly by using <code>map</code> for lists, or <code>second</code> for tuples, or <code>.</code> for functions, etc.)</p></li>
</ul>
<p>Now, to get the value using <code>ix</code>, it’s enough to give our lens <code>id</code> as the “modifying” function (actually, we can even give <code>undefined</code> – it doesn’t matter):</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1"></a><span class="op">&gt;</span> <span class="fu">fst</span> <span class="op">$</span> ix <span class="dv">3</span> <span class="fu">id</span> [<span class="dv">7</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">8</span>]</span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="dv">8</span></span>
<span id="cb9-3"><a href="#cb9-3"></a></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="op">&gt;</span> ix <span class="dv">3</span> <span class="fu">undefined</span> [<span class="dv">7</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">8</span>]</span>
<span id="cb9-5"><a href="#cb9-5"></a>(<span class="dv">8</span>, [<span class="dv">7</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="op">***</span> <span class="dt">Exception</span><span class="op">:</span> Prelude.undefined</span>
<span id="cb9-6"><a href="#cb9-6"></a></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="op">&gt;</span> <span class="fu">fst</span> <span class="op">$</span> ix <span class="dv">3</span> <span class="fu">undefined</span> [<span class="dv">7</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">8</span>]</span>
<span id="cb9-8"><a href="#cb9-8"></a><span class="dv">8</span></span></code></pre></div>
<p>To set the value, we can use <code>const</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1"></a><span class="op">&gt;</span> <span class="fu">snd</span> <span class="op">$</span> ix <span class="dv">3</span> (<span class="fu">const</span> <span class="dv">1000</span>) [<span class="dv">7</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">8</span>]</span>
<span id="cb10-2"><a href="#cb10-2"></a>[<span class="dv">7</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">1000</span>]</span></code></pre></div>
<p>Okay, cool. We have a way to get, set and modify the ith element of a list, and we’re not duplicating any code. Next objection: what if we want to change the value several times?</p>
<h2 id="monads-to-the-rescue">Monads to the rescue!</h2>
<p>Hm, sorry, I’m not explaining very clearly. So, again:</p>
<ul>
<li><p>Imagine that there’s a list.</p></li>
<li><p>Traversing it once takes 1s of time (it’s a huge list).</p></li>
<li><p>And you for whatever reason need 1000 lists, all differing in <em>one</em> element, like this:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1"></a><span class="co">--                      ↓</span></span>
<span id="cb11-2"><a href="#cb11-2"></a>[ [<span class="dv">6</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="op">...</span>, <span class="dv">100</span>, <span class="dv">8</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="op">...</span>]</span>
<span id="cb11-3"><a href="#cb11-3"></a>, [<span class="dv">6</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="op">...</span>, <span class="dv">233</span>, <span class="dv">8</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="op">...</span>]</span>
<span id="cb11-4"><a href="#cb11-4"></a>, [<span class="dv">6</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="op">...</span>, <span class="dv">754</span>, <span class="dv">8</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="op">...</span>]</span>
<span id="cb11-5"><a href="#cb11-5"></a>, [<span class="dv">6</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="op">...</span>, <span class="dv">138</span>, <span class="dv">8</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="op">...</span>]</span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="co">-- and so on</span></span></code></pre></div></li>
<li><p>So, currently you’ll have to call the lens 1000 times, and each time it would have to traverse the list again to get to the element you want to change.</p></li>
<li><p>That’s not nice.</p></li>
</ul>
<p>Let’s change the <code>Lens</code> type again:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1"></a><span class="co">-- This is needed so that we can have constraints in type synonyms.</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="ot">{-# LANGUAGE RankNTypes #-}</span></span>
<span id="cb12-3"><a href="#cb12-3"></a></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="kw">type</span> <span class="dt">Lens</span> s a <span class="ot">=</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (a, m s)</span></code></pre></div>
<p>How does it work? Well, everybody nowadays seems to know that <code>[]</code> is a monad (if you don’t – read a chapter of <a href="http://learnyouahaskell.com/a-fistful-of-monads#the-list-monad">LYAH</a>), and this is how the type of <code>ix</code> looks now when it’s been specialised to use the list monad:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1"></a><span class="ot">ix ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> [a]) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> (a, [[a]])</span></code></pre></div>
<p>Or in English:</p>
<blockquote>
<p>Give me</p>
<ul>
<li>a position in a list of <code>a</code>s (“index”)</li>
<li>a function generating several <code>a</code>s from an <code>a</code></li>
<li>a list of <code>a</code>s</li>
</ul>
<p>and I’ll give you many lists, each having <u>the element at given index</u> replaced by one of the elements generated from the original element. Oh, and I’ll tell you what the original element was as well, in case you want to know.</p>
</blockquote>
<p>Or in the Language Of Examples:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1"></a><span class="op">&gt;</span> ix <span class="dv">2</span> (\x <span class="ot">-&gt;</span> [<span class="dv">1</span><span class="op">..</span>x]) [<span class="dv">300</span>, <span class="dv">100</span>, <span class="dv">4</span>, <span class="dv">600</span>, <span class="dv">900</span>, <span class="dv">400</span>]</span>
<span id="cb14-2"><a href="#cb14-2"></a>(<span class="dv">4</span>, [ [<span class="dv">300</span>, <span class="dv">100</span>, <span class="dv">1</span>, <span class="dv">600</span>, <span class="dv">900</span>, <span class="dv">400</span>]</span>
<span id="cb14-3"><a href="#cb14-3"></a>    , [<span class="dv">300</span>, <span class="dv">100</span>, <span class="dv">2</span>, <span class="dv">600</span>, <span class="dv">900</span>, <span class="dv">400</span>]</span>
<span id="cb14-4"><a href="#cb14-4"></a>    , [<span class="dv">300</span>, <span class="dv">100</span>, <span class="dv">3</span>, <span class="dv">600</span>, <span class="dv">900</span>, <span class="dv">400</span>]</span>
<span id="cb14-5"><a href="#cb14-5"></a>    , [<span class="dv">300</span>, <span class="dv">100</span>, <span class="dv">4</span>, <span class="dv">600</span>, <span class="dv">900</span>, <span class="dv">400</span>] ])</span></code></pre></div>
<p>The implementation doesn’t differ much – we only add a couple of <a href="http://hackage.haskell.org/package/base/docs/Control-Monad.html#v:liftM"><code>liftM</code></a>s and that’s it.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1"></a><span class="ot">ix ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Lens</span> [a] a</span>
<span id="cb15-2"><a href="#cb15-2"></a>ix <span class="fu">index</span> f list</span>
<span id="cb15-3"><a href="#cb15-3"></a>  <span class="op">|</span> <span class="fu">index</span> <span class="op">&lt;</span> <span class="dv">0</span>        <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;ix: negative index&quot;</span></span>
<span id="cb15-4"><a href="#cb15-4"></a>  <span class="op">|</span> <span class="fu">null</span> list        <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;ix: index too large&quot;</span></span>
<span id="cb15-5"><a href="#cb15-5"></a>  <span class="op">|</span> old<span class="op">:</span>rest <span class="ot">&lt;-</span> list <span class="ot">=</span> <span class="kw">if</span> <span class="fu">index</span> <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb15-6"><a href="#cb15-6"></a>                         <span class="kw">then</span> (old, liftM (<span class="op">:</span> rest) (f old))</span>
<span id="cb15-7"><a href="#cb15-7"></a>                         <span class="kw">else</span> second (liftM (old <span class="op">:</span>)) <span class="op">$</span> ix (<span class="fu">index</span><span class="op">-</span><span class="dv">1</span>) f rest</span></code></pre></div>
<p>Now, you might have a question: why specifically <code>Monad</code>?</p>
<p>Well, because then we can do all kinds of nifty things, like generating several values, or using <code>IO</code> in the modifying function, or <code>Maybe</code>… Hm, wait. If we’re only using <code>liftM</code> anyway, do we really need <code>Monad</code> here?</p>
<h2 id="to-hell-with-monads-functors-to-the-rescue">To hell with monads, functors to the rescue!</h2>
<p>Ye-eah, we don’t. All monads are functors (at least in theory, tho starting from GHC 7.10 <a href="http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal">it’s going to become “official”</a>), and <code>Functor f</code> is quite enough to implement <code>ix</code> and do fun stuff with it – why should we ask for more? (Spoiler: we will ask for more… but not until we need it.)</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span></span>
<span id="cb16-2"><a href="#cb16-2"></a></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="kw">type</span> <span class="dt">Lens</span> s a <span class="ot">=</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (a, f s)</span>
<span id="cb16-4"><a href="#cb16-4"></a></span>
<span id="cb16-5"><a href="#cb16-5"></a><span class="ot">ix ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Lens</span> [a] a</span>
<span id="cb16-6"><a href="#cb16-6"></a>ix <span class="fu">index</span> f list</span>
<span id="cb16-7"><a href="#cb16-7"></a>  <span class="op">|</span> <span class="fu">index</span> <span class="op">&lt;</span> <span class="dv">0</span>        <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;ix: negative index&quot;</span></span>
<span id="cb16-8"><a href="#cb16-8"></a>  <span class="op">|</span> <span class="fu">null</span> list        <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;ix: index too large&quot;</span></span>
<span id="cb16-9"><a href="#cb16-9"></a>  <span class="op">|</span> old<span class="op">:</span>rest <span class="ot">&lt;-</span> list <span class="ot">=</span> <span class="kw">if</span> <span class="fu">index</span> <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb16-10"><a href="#cb16-10"></a>                         <span class="kw">then</span> (old, (<span class="op">:</span> rest) <span class="op">&lt;$&gt;</span> f old)</span>
<span id="cb16-11"><a href="#cb16-11"></a>                         <span class="kw">else</span> second ((old <span class="op">:</span>) <span class="op">&lt;$&gt;</span>) <span class="op">$</span> ix (<span class="fu">index</span><span class="op">-</span><span class="dv">1</span>) f rest</span></code></pre></div>
<p>And now let’s repeat. A lens allows us to <em>do something to a big structure</em> given that we know how to <em>do something to a part of it</em>. Note that “doing something” means more than “applying a function” – for instance, “randomly shuffling a list” (which requires IO) or “getting all permutations” (which you could say is done in list monad) are all examples of “doing something”.</p>
<p>Now, another nitpick. Is it really necessary to explicitly return the original value?</p>
<h2 id="setter-is-getter">Setter <em>is</em> getter</h2>
<p>Unfortunately, I don’t know whether I would’ve guessed the right answer if I didn’t know it beforehand, but the answer is “it’s not”, and here’s why.</p>
<p>Meet <code>Storey</code> (don’t bother googling the “canonical” name, it <a href="http://stackoverflow.com/q/26167727/615030">doesn’t seem to exist</a>). This is a <em>functor modifier</em> – it does what the original functor does, but it also attaches a value to it.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1"></a><span class="kw">data</span> <span class="dt">Storey</span> x f a <span class="ot">=</span> <span class="dt">Storey</span> x (f a)</span>
<span id="cb17-2"><a href="#cb17-2"></a>  <span class="kw">deriving</span> <span class="dt">Show</span></span>
<span id="cb17-3"><a href="#cb17-3"></a></span>
<span id="cb17-4"><a href="#cb17-4"></a><span class="kw">instance</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Functor</span> (<span class="dt">Storey</span> x f) <span class="kw">where</span></span>
<span id="cb17-5"><a href="#cb17-5"></a>  <span class="fu">fmap</span> f (<span class="dt">Storey</span> x fa) <span class="ot">=</span> <span class="dt">Storey</span> x (<span class="fu">fmap</span> f fa)</span></code></pre></div>
<p>Or in English:</p>
<ul>
<li><p><code>Storey x f a</code> is conceptually the same as <code>(x, f a)</code>.</p></li>
<li><p>When <code>fmap</code> is used on a <code>Storey</code> value, it leaves the attached value alone and only changes the “main” value.</p></li>
</ul>
<p>Now I’ll show how to use it to get the original value. The trick lies in the different update function we’ll give to the lens this time:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1"></a>(\x <span class="ot">-&gt;</span> <span class="dt">Storey</span> x [<span class="dv">1</span><span class="op">..</span>x])</span></code></pre></div>
<p>It hides the original value – <code>x</code> – inside the functor. From now on all other operations will affect the <em>return value</em> – that is, <code>[1..x]</code> – but not the stored value; and then the stored value will get, unmodified, into the “outer world”, where we would be able to get it by unwrapping <code>Storey</code>.</p>
<p>So, let’s remove the “original value” backdoor:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1"></a><span class="kw">type</span> <span class="dt">Lens</span> s a <span class="ot">=</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> f s</span>
<span id="cb19-2"><a href="#cb19-2"></a></span>
<span id="cb19-3"><a href="#cb19-3"></a><span class="ot">ix ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Lens</span> [a] a</span>
<span id="cb19-4"><a href="#cb19-4"></a>ix <span class="fu">index</span> f list</span>
<span id="cb19-5"><a href="#cb19-5"></a>  <span class="op">|</span> <span class="fu">index</span> <span class="op">&lt;</span> <span class="dv">0</span>        <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;ix: negative index&quot;</span></span>
<span id="cb19-6"><a href="#cb19-6"></a>  <span class="op">|</span> <span class="fu">null</span> list        <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;ix: index too large&quot;</span></span>
<span id="cb19-7"><a href="#cb19-7"></a>  <span class="op">|</span> old<span class="op">:</span>rest <span class="ot">&lt;-</span> list <span class="ot">=</span> <span class="kw">if</span> <span class="fu">index</span> <span class="op">==</span> <span class="dv">0</span></span>
<span id="cb19-8"><a href="#cb19-8"></a>                         <span class="kw">then</span> (<span class="op">:</span> rest) <span class="op">&lt;$&gt;</span> f old</span>
<span id="cb19-9"><a href="#cb19-9"></a>                         <span class="kw">else</span> (old <span class="op">:</span>) <span class="op">&lt;$&gt;</span> ix (<span class="fu">index</span><span class="op">-</span><span class="dv">1</span>) f rest</span></code></pre></div>
<p>And now look how <code>Storey</code> lets us easily get both the original value and the updated structure in one package:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1"></a><span class="op">&gt;</span> ix <span class="dv">2</span> (\x <span class="ot">-&gt;</span> <span class="dt">Storey</span> x [<span class="dv">1</span><span class="op">..</span>x]) [<span class="dv">300</span>, <span class="dv">100</span>, <span class="dv">4</span>, <span class="dv">600</span>, <span class="dv">900</span>, <span class="dv">400</span>]</span>
<span id="cb20-2"><a href="#cb20-2"></a><span class="dt">Storey</span> <span class="dv">4</span> [ [<span class="dv">300</span>, <span class="dv">100</span>, <span class="dv">1</span>, <span class="dv">600</span>, <span class="dv">900</span>, <span class="dv">400</span>]</span>
<span id="cb20-3"><a href="#cb20-3"></a>         , [<span class="dv">300</span>, <span class="dv">100</span>, <span class="dv">2</span>, <span class="dv">600</span>, <span class="dv">900</span>, <span class="dv">400</span>]</span>
<span id="cb20-4"><a href="#cb20-4"></a>         , [<span class="dv">300</span>, <span class="dv">100</span>, <span class="dv">3</span>, <span class="dv">600</span>, <span class="dv">900</span>, <span class="dv">400</span>]</span>
<span id="cb20-5"><a href="#cb20-5"></a>         , [<span class="dv">300</span>, <span class="dv">100</span>, <span class="dv">4</span>, <span class="dv">600</span>, <span class="dv">900</span>, <span class="dv">400</span>] ]</span></code></pre></div>
<p>Ha!</p>
<h2 id="always-always-benchmark">Always, always benchmark</h2>
<p>Just wondering: did this explanation seem legit to you?</p>
<blockquote>
<p>So, currently you’ll have to call the lens 1000 times, and each time it would have to traverse the list again to get to the element you want to change.</p>
</blockquote>
<p>If so, this is yet another proof that you should Always Benchmark First [I think it’s a quote, but I can’t remember the source]. In reality, the functor-based lens is around 3× slower than an ordinary function, even if the latter is called 1000 times. Here’s the reason:</p>
<ul>
<li><p>A list with its last element modified is a completely <em>new</em> list. 2 lists can share a tail, yep, but they can’t share their beginnings.</p></li>
<li><p>So, when you modify the last element of a list, you’re creating a brand new list.</p></li>
<li><p>When the functor lens changes some element 1000 times, it still has to create 1000 new lists. It’s not a cheap operation.</p></li>
<li><p>Both functor and ordinary lens create those lists during traversal. There’s no actual difference in what’s being done.</p></li>
<li><p>So, the functor lens <em>can’t</em> be faster, at least on lists. It would be faster for data structures where updating is cheaper than getting, but not for lists or trees (such as <code>Map</code> or <code>Seq</code>).</p></li>
<li><p>One example of such a data structure is map implemented as a list of key–value pairs (updating is as simple as adding a new pair to the list, but getting requires traversing the list).</p></li>
</ul>
<p>There are many reasons why lenses are awesome, but performance isn’t one of them. (Not saying lenses are slow… merely that they generally aren’t faster than “usual” functions.)</p>
<h2 id="why-preserve-the-type">Why preserve the type?</h2>
<p>Nothing actually prevents us from changing the <em>type</em> of the part we’re modifying as well (you might’ve noticed it by yourself already, but I still wanted to point this out). So, the actual type for lenses is:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1"></a><span class="kw">type</span> <span class="dt">Lens</span> s t a b <span class="ot">=</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> f t</span>
<span id="cb21-2"><a href="#cb21-2"></a></span>
<span id="cb21-3"><a href="#cb21-3"></a><span class="kw">type</span> <span class="dt">Lens&#39;</span> s a <span class="ot">=</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> f s</span></code></pre></div>
<p>(<code>Lens'</code> means something like “simple lens”. Also, you can read <code>s</code> and <code>t</code> as “source” and “target”.)</p>
<h2 id="composing-functors">Composing functors</h2>
<p>You might wonder: shouldn’t it be possible to somehow reuse the <code>(,)</code> instance for <code>Functor</code>? After all, the functor instance for <code>(,)</code> applies the function to the second part of the tuple:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1"></a><span class="op">&gt;</span> <span class="fu">fmap</span> <span class="fu">not</span> (<span class="dv">1</span>, <span class="dt">False</span>)</span>
<span id="cb22-2"><a href="#cb22-2"></a>(<span class="dv">1</span>, <span class="dt">True</span>)</span></code></pre></div>
<p>which is pretty similar to what <code>fmap</code> does to <code>Storey</code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1"></a><span class="fu">fmap</span> f        (x, a) <span class="ot">=</span>     (x,) <span class="op">$</span>      f a</span>
<span id="cb23-2"><a href="#cb23-2"></a><span class="fu">fmap</span> f (<span class="dt">Storey</span> x  a) <span class="ot">=</span> <span class="dt">Storey</span> x <span class="op">$</span> <span class="fu">fmap</span> f a</span></code></pre></div>
<p>If you think about it a bit, <code>Storey</code> kinda looks like a <em>composition</em> of <code>(,)</code> and a functor. If we pretend for a moment that we can use <code>.</code> and <code>$</code> on types…</p>
<ul>
<li><code>data Storey x f a = Storey x (f a)</code></li>
<li><code>data Storey x f a = Storey x . f $ a</code></li>
<li><code>data Storey x f = Storey x . f</code></li>
</ul>
<p>And since we already know that <code>Storey x</code> is like <code>(,) x</code>…</p>
<ul>
<li><code>data Storey x f = (,) x . f</code></li>
</ul>
<p>So, is there some kind of <code>.</code> for types? Yes, and it’s called (kinda appropriately) <a href="https://hackage.haskell.org/package/base/docs/Data-Functor-Compose.html#t:Compose"><code>Compose</code></a>. Using it is really simple:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1"></a><span class="kw">type</span> <span class="dt">Storey</span> x f <span class="ot">=</span> <span class="dt">Compose</span> ((,) x) f</span></code></pre></div>
<p>Actually, we don’t even need this type declaration:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1"></a><span class="op">&gt;</span> <span class="co">-- Compare with the original:</span></span>
<span id="cb25-2"><a href="#cb25-2"></a><span class="op">&gt;</span> <span class="co">--           ix 2 (\x -&gt; Storey   x  [1..x] ) [300, 100, 4, 600, 900, 400]</span></span>
<span id="cb25-3"><a href="#cb25-3"></a><span class="op">&gt;</span> getCompose <span class="op">$</span> ix <span class="dv">2</span> (\x <span class="ot">-&gt;</span> <span class="dt">Compose</span> (x, [<span class="dv">1</span><span class="op">..</span>x])) [<span class="dv">300</span>, <span class="dv">100</span>, <span class="dv">4</span>, <span class="dv">600</span>, <span class="dv">900</span>, <span class="dv">400</span>]</span>
<span id="cb25-4"><a href="#cb25-4"></a>(<span class="dv">4</span>, [ [<span class="dv">300</span>, <span class="dv">100</span>, <span class="dv">1</span>, <span class="dv">600</span>, <span class="dv">900</span>, <span class="dv">400</span>]</span>
<span id="cb25-5"><a href="#cb25-5"></a>    , [<span class="dv">300</span>, <span class="dv">100</span>, <span class="dv">2</span>, <span class="dv">600</span>, <span class="dv">900</span>, <span class="dv">400</span>]</span>
<span id="cb25-6"><a href="#cb25-6"></a>    , [<span class="dv">300</span>, <span class="dv">100</span>, <span class="dv">3</span>, <span class="dv">600</span>, <span class="dv">900</span>, <span class="dv">400</span>]</span>
<span id="cb25-7"><a href="#cb25-7"></a>    , [<span class="dv">300</span>, <span class="dv">100</span>, <span class="dv">4</span>, <span class="dv">600</span>, <span class="dv">900</span>, <span class="dv">400</span>] ])</span></code></pre></div>
<p>Do you completely understand what’s going on?</p>
<ul>
<li><p><code>f</code> and <code>g</code> may be functors, but <code>type FG a = f (g a)</code> won’t automatically become one.</p></li>
<li><p>However, <code>type FG a = Compose f g a</code> (or <code>type FG = Compose f g</code>) <em>will</em>.</p></li>
<li><p>In our example, we couldn’t use <code>ix</code> on <code>(\x -&gt; (x, [1..x]))</code> because <code>(x, [1..x])</code> has type <code>(a, [a])</code>, which is a composition of 2 functors – <code>(,) a</code> and <code>[]</code> – but isn’t a <code>Functor</code> itself.</p></li>
<li><p>Applying <code>Compose</code> to <code>(x, [1..x])</code> is enough to make it a proper functor. Then <code>ix</code> can do its job.</p></li>
<li><p><code>getCompose</code> extracts the “functor-of-functor” value from <code>Compose</code>.</p></li>
</ul>
<p>Good, now to the next question.</p>
<h2 id="what-if-i-dont-need-any-functors">What if I don’t need any functors?</h2>
<p>If you just want to set or modify the value, use <a href="http://hackage.haskell.org/package/base/docs/Data-Functor-Identity.html#t:Identity"><code>Identity</code></a>, which is precisely the functor to use when you don’t actually need one.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1"></a><span class="op">&gt;</span> <span class="co">-- Setting.</span></span>
<span id="cb26-2"><a href="#cb26-2"></a><span class="op">&gt;</span> runIdentity <span class="op">$</span> ix <span class="dv">2</span> (\x <span class="ot">-&gt;</span> <span class="dt">Identity</span> <span class="dv">88</span>) [<span class="dv">0</span><span class="op">..</span><span class="dv">4</span>]</span>
<span id="cb26-3"><a href="#cb26-3"></a>[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">88</span>, <span class="dv">3</span>, <span class="dv">4</span>]</span>
<span id="cb26-4"><a href="#cb26-4"></a></span>
<span id="cb26-5"><a href="#cb26-5"></a><span class="op">&gt;</span> <span class="co">-- Modification.</span></span>
<span id="cb26-6"><a href="#cb26-6"></a><span class="op">&gt;</span> runIdentity <span class="op">$</span> ix <span class="dv">2</span> (\x <span class="ot">-&gt;</span> <span class="dt">Identity</span> (x <span class="op">*</span> <span class="dv">44</span>)) [<span class="dv">0</span><span class="op">..</span><span class="dv">4</span>]</span>
<span id="cb26-7"><a href="#cb26-7"></a>[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">88</span>, <span class="dv">3</span>, <span class="dv">4</span>]</span></code></pre></div>
<p>Since it happens <del>kinda</del> really often that you won’t need a functor, it’s better to have a function to do the wrapping–unwrapping of <code>Identity</code> for you. In lens it’s called <code>over</code>:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1"></a><span class="ot">over ::</span> <span class="dt">Lens</span> s t a b <span class="ot">-&gt;</span> ((a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> t)</span>
<span id="cb27-2"><a href="#cb27-2"></a>over l f <span class="ot">=</span> runIdentity <span class="op">.</span> l (<span class="dt">Identity</span> <span class="op">.</span> f)</span></code></pre></div>
<p>So, our 2 examples can be rewritten like</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1"></a><span class="op">&gt;</span> over (ix <span class="dv">2</span>) (<span class="fu">const</span> <span class="dv">88</span>) [<span class="dv">0</span><span class="op">..</span><span class="dv">4</span>]</span>
<span id="cb28-2"><a href="#cb28-2"></a>[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">88</span>, <span class="dv">3</span>, <span class="dv">4</span>]</span>
<span id="cb28-3"><a href="#cb28-3"></a></span>
<span id="cb28-4"><a href="#cb28-4"></a><span class="op">&gt;</span> over (ix <span class="dv">2</span>) (<span class="op">*</span> <span class="dv">44</span>) [<span class="dv">0</span><span class="op">..</span><span class="dv">4</span>]</span>
<span id="cb28-5"><a href="#cb28-5"></a>[<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">88</span>, <span class="dv">3</span>, <span class="dv">4</span>]</span></code></pre></div>
<h2 id="what-if-i-dont-need-any-modifications">What if I don’t need any modifications?</h2>
<p>Oka-ay. If you only want to get the value, without updating anything, you can use <a href="http://hackage.haskell.org/package/base/docs/Control-Applicative.html#v:Const"><code>Const</code></a>, which is like our <code>Storey</code> but without the functor part – and it’s also in the base libraries. Compare: this is the <code>Storey</code> version of a function which uses a lens to extract some value:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1"></a>getByStorey lens s <span class="ot">=</span> x</span>
<span id="cb29-2"><a href="#cb29-2"></a>  <span class="kw">where</span></span>
<span id="cb29-3"><a href="#cb29-3"></a>    <span class="dt">Storey</span> x _ <span class="ot">=</span> lens (\x <span class="ot">-&gt;</span> <span class="dt">Storey</span> x (<span class="dt">Identity</span> x)) s</span></code></pre></div>
<p>And this is the <code>Const</code> version:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1"></a>getByConst lens s <span class="ot">=</span> x</span>
<span id="cb30-2"><a href="#cb30-2"></a>  <span class="kw">where</span></span>
<span id="cb30-3"><a href="#cb30-3"></a>    <span class="dt">Const</span> x <span class="ot">=</span> lens (\x <span class="ot">-&gt;</span> <span class="dt">Const</span> x) s</span></code></pre></div>
<p>(<code>getByConst</code> is called <code>view</code> in lens.)</p>
<p>Please note that the main difference between <code>Const</code> and <code>Storey</code> is in their <em>constructors,</em> not types. Speaking in <del>silly</del> easily comprehensible metaphors, <code>Storey</code> is a box containing humanitarian aid, with a letter glued to the box, while <code>Const</code> is the same box with the same letter, except that… there’s no humanitarian aid, because the box is too small for it. But you still insist that it <em>is</em> a box of humanitarian aid (merely containing 0 items) and therefore you are entitled to a free delivery (because your country has a law stating that every citizen can use post services free of charge if they’re sending humanitarian aid). Your parcel is accepted, but the post workers hate you. You don’t care – your grandpa in Africa would love to get your letter, nothing else matters.</p>
<p>Here are the definitions of <code>Const</code> and <code>Storey</code> for you to compare, and after that we will move on.</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1"></a><span class="kw">data</span> <span class="dt">Storey</span> x f a  <span class="ot">=</span> <span class="dt">Storey</span> x (f a)</span>
<span id="cb31-2"><a href="#cb31-2"></a><span class="kw">data</span> <span class="dt">Const</span>  x  a   <span class="ot">=</span> <span class="dt">Const</span>  x</span></code></pre></div>
<p>(By the way, we could implement <code>Storey</code> using <code>Const</code> and <a href="http://hackage.haskell.org/package/transformers/docs/Data-Functor-Product.html#t:Product"><code>Product</code></a> instead of <code>(,)</code> and <code>Compose</code>. Bonus points if you do it without opening the link.)</p>
<h2 id="test-yourself">Test yourself</h2>
<p>At this point you should be able to write the following (you can copy and paste this whole chunk into GHCi and it would work because I replicated type synonyms and imports as well) (oh, and there are <a href="https://www.haskell.org/ghc/docs/latest/html/users_guide/typed-holes.html">typed holes</a> added for your convenience, but if you write these functions merely by blindly following the types, it doesn’t count):</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1"></a><span class="ot">{-# LANGUAGE</span></span>
<span id="cb32-2"><a href="#cb32-2"></a><span class="ot">RankNTypes,</span></span>
<span id="cb32-3"><a href="#cb32-3"></a><span class="ot">TupleSections</span></span>
<span id="cb32-4"><a href="#cb32-4"></a><span class="ot">  #-}</span></span>
<span id="cb32-5"><a href="#cb32-5"></a></span>
<span id="cb32-6"><a href="#cb32-6"></a><span class="kw">import</span> <span class="dt">Control.Applicative</span></span>
<span id="cb32-7"><a href="#cb32-7"></a></span>
<span id="cb32-8"><a href="#cb32-8"></a><span class="kw">type</span> <span class="dt">Lens</span> s t a b <span class="ot">=</span> <span class="kw">forall</span> f<span class="op">.</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> f t</span>
<span id="cb32-9"><a href="#cb32-9"></a><span class="kw">type</span> <span class="dt">Lens&#39;</span> s a <span class="ot">=</span> <span class="dt">Lens</span> s s a a</span>
<span id="cb32-10"><a href="#cb32-10"></a></span>
<span id="cb32-11"><a href="#cb32-11"></a><span class="co">-- _1 :: Functor f =&gt; (a -&gt; f b) -&gt; (a, x) -&gt; f (b, x)</span></span>
<span id="cb32-12"><a href="#cb32-12"></a><span class="ot">_1 ::</span> <span class="dt">Lens</span> (a, x) (b, x) a b</span>
<span id="cb32-13"><a href="#cb32-13"></a>_1 <span class="ot">=</span> _</span>
<span id="cb32-14"><a href="#cb32-14"></a></span>
<span id="cb32-15"><a href="#cb32-15"></a><span class="co">-- _2 :: Functor f =&gt; (a -&gt; f b) -&gt; (x, a) -&gt; f (x, b)</span></span>
<span id="cb32-16"><a href="#cb32-16"></a><span class="ot">_2 ::</span> <span class="dt">Lens</span> (x, a) (x, b) a b</span>
<span id="cb32-17"><a href="#cb32-17"></a>_2 <span class="ot">=</span> _</span>
<span id="cb32-18"><a href="#cb32-18"></a></span>
<span id="cb32-19"><a href="#cb32-19"></a><span class="co">-- Make a lens out of a getter and a setter.</span></span>
<span id="cb32-20"><a href="#cb32-20"></a><span class="ot">lens ::</span> (s <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (s <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> t) <span class="ot">-&gt;</span> <span class="dt">Lens</span> s t a b</span>
<span id="cb32-21"><a href="#cb32-21"></a>lens get set <span class="ot">=</span> _</span>
<span id="cb32-22"><a href="#cb32-22"></a></span>
<span id="cb32-23"><a href="#cb32-23"></a><span class="co">-- Combine 2 lenses to make a lens which works on Either. (It&#39;s a good idea</span></span>
<span id="cb32-24"><a href="#cb32-24"></a><span class="co">-- to try to use bimap for this, but it won&#39;t work, and you have to use</span></span>
<span id="cb32-25"><a href="#cb32-25"></a><span class="co">-- explicit case-matching. Still a good idea, tho.)</span></span>
<span id="cb32-26"><a href="#cb32-26"></a><span class="ot">choosing ::</span> <span class="dt">Lens</span> s1 t1 a b <span class="ot">-&gt;</span> <span class="dt">Lens</span> s2 t2 a b</span>
<span id="cb32-27"><a href="#cb32-27"></a>         <span class="ot">-&gt;</span> <span class="dt">Lens</span> (<span class="dt">Either</span> s1 s2) (<span class="dt">Either</span> t1 t2) a b</span>
<span id="cb32-28"><a href="#cb32-28"></a>choosing l1 l2 <span class="ot">=</span> _</span>
<span id="cb32-29"><a href="#cb32-29"></a></span>
<span id="cb32-30"><a href="#cb32-30"></a><span class="co">-- Modify the target of a lens and return the result. (Bonus points if you</span></span>
<span id="cb32-31"><a href="#cb32-31"></a><span class="co">-- do it without lambdas and defining new functions. There&#39;s also a hint</span></span>
<span id="cb32-32"><a href="#cb32-32"></a><span class="co">-- before the end of the section, so don&#39;t scroll if you don&#39;t want it.)</span></span>
<span id="cb32-33"><a href="#cb32-33"></a><span class="ot">(&lt;%~) ::</span> <span class="dt">Lens</span> s t a b <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (b, t)</span>
<span id="cb32-34"><a href="#cb32-34"></a>(<span class="op">&lt;%~</span>) l f s <span class="ot">=</span> _</span>
<span id="cb32-35"><a href="#cb32-35"></a></span>
<span id="cb32-36"><a href="#cb32-36"></a><span class="co">-- Modify the target of a lens, but return the old value.</span></span>
<span id="cb32-37"><a href="#cb32-37"></a><span class="ot">(&lt;&lt;%~) ::</span> <span class="dt">Lens</span> s t a b <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (a, t)</span>
<span id="cb32-38"><a href="#cb32-38"></a>(<span class="op">&lt;&lt;%~</span>) l f s <span class="ot">=</span> _</span>
<span id="cb32-39"><a href="#cb32-39"></a></span>
<span id="cb32-40"><a href="#cb32-40"></a><span class="co">-- There&#39;s a () in every value. (No idea what this one is for, maybe it&#39;ll</span></span>
<span id="cb32-41"><a href="#cb32-41"></a><span class="co">-- become clear later.)</span></span>
<span id="cb32-42"><a href="#cb32-42"></a><span class="ot">united ::</span> <span class="dt">Lens&#39;</span> s ()</span>
<span id="cb32-43"><a href="#cb32-43"></a>united <span class="ot">=</span> _</span></code></pre></div>
<p>Please stop drinking your tea now and <em>do</em> it. No, really, even if it’s a totally stupid exercise. Haven’t you ever been in a situation when you have to do something simple, and you look at the screen/keyboard and realise that you don’t know how to start? You stare at the letters and symbols – “<code>a</code>”, “<code>s</code>”, “tuple”, “this goes there”, “if this accepts this then it would be like <em>this</em>”… – but brain refuses to do its job. You are despised by your peers and laughed at by your enemies. To not let this happen, <em>please</em> write the definitions for these functions.</p>
<p>Thanks.</p>
<p>[Now I’m wondering whether to admit that <code>united</code> took me more than 2min…]</p>
<p>Here’s a hint for <code>&lt;%~</code>: it involves the tuple functor.</p>
<h2 id="recap">Recap</h2>
<p>(I promised explaining everything many times but didn’t promise that explanations would be different every time, right?)</p>
<ul>
<li><p>Lenses are like <code>modify :: (a -&gt; b) -&gt; s -&gt; t</code>, where <code>a</code> is a part of <code>s</code> (“source”), and <code>t</code> (“target”) is what happens to <code>s</code> when the <code>a</code>-typed subpart is replaced by the <code>b</code>-typed subpart. Except that lenses are actually like <code>ultraModify :: Functor f =&gt; (a -&gt; f b) -&gt; s -&gt; f t</code>… and this <code>f</code> here enables us to do <em>lots</em> of cool stuff.</p></li>
<li><p>If you want a lens to be like an ordinary <code>modify</code>, use <code>Identity</code> in place of <code>f</code>. This is done by <code>over</code> in lens.</p></li>
<li><p>If you want to use the lens as a getter, use <code>Const</code> as <code>f</code> – it would store the <code>a</code> value and “carry it to the outside” for you. This is done by <code>view</code> in lens.</p></li>
<li><p>You <em>don’t</em> need any special <code>overM</code> to update the value using <code>IO</code> or something – just apply the lens directly. <code>over</code> is merely a convenient shortcut to wrap and unwrap <code>Identity</code>.</p></li>
<li><p>You can create a lens from a getter and a setter, but it might be less than optimal (because this way <code>modify</code> would necessarily be a combination of <code>get</code> and <code>set</code>, instead of a single “dive” into the data structure).</p></li>
</ul>
<p>Bonus stuff:</p>
<ul>
<li><p>Functors can be composed with <a href="https://hackage.haskell.org/package/base/docs/Data-Functor-Compose.html#t:Compose"><code>Compose</code></a>.</p></li>
<li><p><a href="http://hackage.haskell.org/package/base/docs/Data-Bifunctor.html#v:second"><code>second</code></a> from <code>Data.Bifunctor</code> or <code>Control.Arrow</code> maps over the second element of a tuple.</p></li>
<li><p><a href="http://hackage.haskell.org/package/base/docs/Data-Bifunctor.html">Bifunctors</a> are like functors with 2 type parameters.</p></li>
</ul>
<h1 id="traversals-101">Traversals 101</h1>
<p>A lens focuses on a single value – it doesn’t matter whether it’s <em>actually</em> a single value or not, as long as <em>conceptually</em> it is. A couple of examples to illustrate what I’m talking about:</p>
<ul>
<li><p>We can make a lens for changing the absolute value of a number (which technically isn’t even “contained” in the number):</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1"></a><span class="ot">_abs ::</span> <span class="dt">Real</span> a <span class="ot">=&gt;</span> <span class="dt">Lens&#39;</span> a a</span>
<span id="cb33-2"><a href="#cb33-2"></a>_abs f n <span class="ot">=</span> update <span class="op">&lt;$&gt;</span> f (<span class="fu">abs</span> n)</span>
<span id="cb33-3"><a href="#cb33-3"></a>  <span class="kw">where</span></span>
<span id="cb33-4"><a href="#cb33-4"></a>    update x</span>
<span id="cb33-5"><a href="#cb33-5"></a>      <span class="op">|</span> x <span class="op">&lt;</span> <span class="dv">0</span>     <span class="ot">=</span> <span class="fu">error</span> <span class="st">&quot;_abs: absolute value can&#39;t be negative&quot;</span></span>
<span id="cb33-6"><a href="#cb33-6"></a>      <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> <span class="fu">signum</span> n <span class="op">*</span> x</span></code></pre></div>
<p>To demonstrate, I’ll square the <code>10</code> contained in <code>-10</code>:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1"></a><span class="op">&gt;</span> over _abs (<span class="op">^</span><span class="dv">2</span>) (<span class="op">-</span><span class="dv">10</span>)</span>
<span id="cb34-2"><a href="#cb34-2"></a><span class="op">-</span><span class="dv">100</span></span></code></pre></div></li>
<li><p>We can make a lens for focusing on several elements in the list, as long as they are equal to the given one:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1"></a><span class="ot">_all ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Lens&#39;</span> [a] a</span>
<span id="cb35-2"><a href="#cb35-2"></a>_all ref <span class="ot">=</span> lens get set</span>
<span id="cb35-3"><a href="#cb35-3"></a>  <span class="kw">where</span></span>
<span id="cb35-4"><a href="#cb35-4"></a>    get s     <span class="ot">=</span> ref</span>
<span id="cb35-5"><a href="#cb35-5"></a>    set s new <span class="ot">=</span> <span class="fu">map</span> (\old <span class="ot">-&gt;</span> <span class="kw">if</span> old <span class="op">==</span> ref <span class="kw">then</span> new <span class="kw">else</span> old) s</span></code></pre></div>
<p>To demonstrate, I’ll change all <code>0</code>s in a list into <code>-8</code>s:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1"></a><span class="op">&gt;</span> set (_all <span class="dv">0</span>) (<span class="op">-</span><span class="dv">8</span>) [<span class="dv">100</span>, <span class="dv">600</span>, <span class="dv">0</span>, <span class="dv">200</span>, <span class="dv">0</span>]</span>
<span id="cb36-2"><a href="#cb36-2"></a>[<span class="dv">100</span>, <span class="dv">600</span>, <span class="op">-</span><span class="dv">8</span>, <span class="dv">200</span>, <span class="op">-</span><span class="dv">8</span>]</span></code></pre></div>
<p>Note that <code>_all</code>’s behavior is probably different from what you expect. For instance, let’s say I want to ask user for the replacement value each time I stumble upon a <code>0</code>:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1"></a><span class="op">&gt;</span> (_all <span class="dv">0</span>) (<span class="fu">const</span> <span class="op">$</span> <span class="fu">putStr</span> <span class="st">&quot;? new: &quot;</span> <span class="op">&gt;&gt;</span> <span class="fu">readLn</span>) [<span class="dv">100</span>, <span class="dv">600</span>, <span class="dv">0</span>, <span class="dv">200</span>, <span class="dv">0</span>]</span>
<span id="cb37-2"><a href="#cb37-2"></a><span class="op">?</span> new<span class="op">:</span> <span class="dv">13</span></span>
<span id="cb37-3"><a href="#cb37-3"></a>[<span class="dv">100</span>, <span class="dv">600</span>, <span class="dv">13</span>, <span class="dv">200</span>, <span class="dv">13</span>]</span></code></pre></div>
<p>The user was asked for the value only once, but there are 2 <code>0</code>s in the list. How come? Well, it’s simple: a lens depends on a functor (<code>IO</code> in this case), and you <em>can’t</em> execute an action several times using only the <code>Functor</code> interface.</p>
<p>It wasn’t obvious to me, so it might not be obvious to you either… and thus I’d better elaborate. Let’s say you have <code>launchMissiles :: IO ()</code>:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1"></a>launchMissiles <span class="ot">=</span> <span class="fu">putStrLn</span> <span class="st">&quot;kaboom!&quot;</span></span></code></pre></div>
<p>Using <code>Monad</code>, you can launch missiles twice:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1"></a><span class="op">&gt;</span> launchMissiles <span class="op">&gt;&gt;</span> launchMissiles</span>
<span id="cb39-2"><a href="#cb39-2"></a>kaboom<span class="op">!</span></span>
<span id="cb39-3"><a href="#cb39-3"></a>kaboom<span class="op">!</span></span></code></pre></div>
<p>You can even do it using <code>Applicative</code>:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb40-1"><a href="#cb40-1"></a><span class="op">&gt;</span> launchMissiles <span class="op">*&gt;</span> launchMissiles</span>
<span id="cb40-2"><a href="#cb40-2"></a>kaboom<span class="op">!</span></span>
<span id="cb40-3"><a href="#cb40-3"></a>kaboom<span class="op">!</span></span></code></pre></div>
<p>But you can’t do it using <code>Functor</code>; the only thing you can do is replace the returned <code>()</code> (what for? I’ve no idea):</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb41-1"><a href="#cb41-1"></a><span class="op">&gt;</span> <span class="st">&quot;:(&quot;</span> <span class="op">&lt;$</span> launchMissiles</span>
<span id="cb41-2"><a href="#cb41-2"></a>kaboom<span class="op">!</span></span>
<span id="cb41-3"><a href="#cb41-3"></a><span class="st">&quot;:(&quot;</span></span></code></pre></div></li>
</ul>
<h2 id="the-road-to-power">The road to power</h2>
<p>The last example (with <code>_all</code>) makes one wonder: what additional power would we get if <code>Functor</code> in the definition of <code>Lens</code> was replaced with <code>Applicative</code>? Well, for one, we’d be able to write a better <code>_all</code>.</p>
<p>First, type synonyms for our “applicative lenses”:</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb42-1"><a href="#cb42-1"></a><span class="kw">type</span> <span class="dt">AppLens</span> s t a b <span class="ot">=</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> f t</span>
<span id="cb42-2"><a href="#cb42-2"></a><span class="kw">type</span> <span class="dt">AppLens&#39;</span> s a <span class="ot">=</span> <span class="dt">AppLens</span> s s a a</span></code></pre></div>
<p>Now, here’s how the type of <code>_all'</code> looks like:</p>
<ul>
<li>unexpanded: <code>_all' :: Eq a =&gt; a -&gt; AppLens' [a] a</code></li>
<li>expanded: <code>_all' :: (Applicative f, Eq a) =&gt; a -&gt; (a -&gt; f a) -&gt; [a] -&gt; f [a]</code></li>
</ul>
<h2 id="a-clarification-about-_all">A clarification about <code>_all</code></h2>
<p><code>_all</code> is written using <code>lens</code> and simple getters and setters. Even if you have written <code>lens</code> after I asked you to, it still might not be clear to you how <code>_all</code> works (it wasn’t for me). If it <em>is</em> very clear to you how <code>_all</code> works, skip this section; otherwise, read on.</p>
<ul>
<li><p><code>fmap</code> allows acting on a value inside the functor:</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb43-1"><a href="#cb43-1"></a><span class="fu">fmap</span><span class="ot"> ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f a <span class="ot">-&gt;</span> f b</span></code></pre></div></li>
<li><p>The <code>_all</code> lens is provided with a value of type <code>a</code> (the “reference value”), a function of type <code>a -&gt; f a</code>, and the list:</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb44-1"><a href="#cb44-1"></a>_all ref f list <span class="ot">=</span> <span class="op">...</span></span></code></pre></div></li>
<li><p>Since we consider all equal values to be the <em>same</em> value, we can immediately combine <code>ref</code> and <code>f</code> to get the updated value:</p>
<div class="sourceCode" id="cb45"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb45-1"><a href="#cb45-1"></a>f&#39;new <span class="ot">=</span> f ref</span></code></pre></div>
<p>We have to do it <em>anyway,</em> because there’s no way to get a value of type <code>f a</code> otherwise (e.g. the given list might be empty; note that we can’t use <code>pure</code> as it’s in <code>Applicative</code> and not <code>Functor</code>). For instance, this means that in case of <code>IO</code>, the action would be executed even if there are no values equal to <code>ref</code> in the list.</p></li>
<li><p>If we have the <code>ref</code> value and the <code>new</code> value, we can do a replacement in the list without resorting to functors at all – it’s simply</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb46-1"><a href="#cb46-1"></a>getModifiedList new <span class="ot">=</span> <span class="fu">map</span> (\old <span class="ot">-&gt;</span> <span class="kw">if</span> old <span class="op">==</span> ref <span class="kw">then</span> new <span class="kw">else</span> old) list</span></code></pre></div></li>
<li><p>We don’t have the <code>new</code> value, but we have <code>f'new</code> which contains it – so we can do <code>getModifiedList &lt;$&gt; f'new</code> to get a value of type <code>f [a]</code>. The end.</p></li>
</ul>
<h2 id="writing-a-better-_all">Writing a better <code>_all</code></h2>
<p>This time we want to do it without “cheating”, and honestly call <code>f</code> for each of the values we’ll be replacing. So, we can already write the update function:</p>
<div class="sourceCode" id="cb47"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb47-1"><a href="#cb47-1"></a><span class="ot">_all&#39; ::</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> <span class="op">...</span></span>
<span id="cb47-2"><a href="#cb47-2"></a>_all&#39; ref <span class="op">...</span></span>
<span id="cb47-3"><a href="#cb47-3"></a>  <span class="kw">where</span></span>
<span id="cb47-4"><a href="#cb47-4"></a>    <span class="co">-- update :: a -&gt; f a</span></span>
<span id="cb47-5"><a href="#cb47-5"></a>    update old <span class="ot">=</span> <span class="kw">if</span> old <span class="op">==</span> ref <span class="kw">then</span> f old <span class="kw">else</span> <span class="fu">pure</span> old</span></code></pre></div>
<p>The only thing left is to apply it to the list and gather the results! If <code>f</code> was a monad, we could’ve use <code>mapM</code>:</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb48-1"><a href="#cb48-1"></a><span class="ot">_all&#39; ::</span> (<span class="dt">Monad</span> m, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> m [a]</span>
<span id="cb48-2"><a href="#cb48-2"></a>_all&#39; ref f s <span class="ot">=</span> <span class="fu">mapM</span> update s</span>
<span id="cb48-3"><a href="#cb48-3"></a>  <span class="kw">where</span></span>
<span id="cb48-4"><a href="#cb48-4"></a>    update old <span class="ot">=</span> <span class="kw">if</span> old <span class="op">==</span> ref <span class="kw">then</span> f old <span class="kw">else</span> <span class="fu">return</span> old</span></code></pre></div>
<p>(Do you see now how lenses are really just ordinary functions in clever disguises? If <code>_all'</code> was in some list library, betcha it would’ve been called <code>mapOnEqM</code> or something.)</p>
<p>However, <code>f</code> is an applicative functor and not a monad. How do you think is <code>mapM</code> for <code>Applicative</code> called? No, it’s not <code>mapA</code> (I wish) – it’s <a href="http://hackage.haskell.org/package/base/docs/Data-Traversable.html#v:traverse"><code>traverse</code></a>.</p>
<p>With <code>traverse</code>, we can finally write <code>_all'</code>:</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb49-1"><a href="#cb49-1"></a><span class="ot">_all&#39; ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">AppLens&#39;</span> [a] a</span>
<span id="cb49-2"><a href="#cb49-2"></a>_all&#39; ref f s <span class="ot">=</span> <span class="fu">traverse</span> update s</span>
<span id="cb49-3"><a href="#cb49-3"></a>  <span class="kw">where</span></span>
<span id="cb49-4"><a href="#cb49-4"></a>    update old <span class="ot">=</span> <span class="kw">if</span> old <span class="op">==</span> ref <span class="kw">then</span> f old <span class="kw">else</span> <span class="fu">pure</span> old</span></code></pre></div>
<div class="sourceCode" id="cb50"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb50-1"><a href="#cb50-1"></a><span class="op">&gt;</span> (_all&#39; <span class="dv">0</span>) (<span class="fu">const</span> <span class="op">$</span> <span class="fu">putStr</span> <span class="st">&quot;? new: &quot;</span> <span class="op">&gt;&gt;</span> <span class="fu">readLn</span>) [<span class="dv">100</span>, <span class="dv">600</span>, <span class="dv">0</span>, <span class="dv">200</span>, <span class="dv">0</span>]</span>
<span id="cb50-2"><a href="#cb50-2"></a><span class="op">?</span> new<span class="op">:</span> <span class="dv">11</span></span>
<span id="cb50-3"><a href="#cb50-3"></a><span class="op">?</span> new<span class="op">:</span> <span class="dv">22</span></span>
<span id="cb50-4"><a href="#cb50-4"></a>[<span class="dv">100</span>, <span class="dv">600</span>, <span class="dv">11</span>, <span class="dv">200</span>, <span class="dv">22</span>]</span></code></pre></div>
<h2 id="updating-view-over-and-set">Updating <code>view</code>, <code>over</code> and <code>set</code></h2>
<p>Unfortunately, you won’t be able to use <code>view</code>, <code>over</code> and <code>set</code> with <code>_all'</code> yet. Remember their types?</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb51-1"><a href="#cb51-1"></a><span class="ot">view ::</span> <span class="dt">Lens</span> s t a b <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a</span>
<span id="cb51-2"><a href="#cb51-2"></a><span class="ot">over ::</span> <span class="dt">Lens</span> s t a b <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> t</span>
<span id="cb51-3"><a href="#cb51-3"></a><span class="ot">set  ::</span> <span class="dt">Lens</span> s t a b <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> t</span></code></pre></div>
<p><code>Lens</code> won’t do when we have an <code>AppLens</code>. Why? Because <code>AppLens</code>’s requirements to its arguments are <em>more strict</em> – in the same way you can’t give <code>view</code> a “lens” of type <code>(a -&gt; Maybe b) -&gt; s -&gt; Maybe t</code>. It’s <code>view</code> that gets to choose what type it wants, not the lens.</p>
<p>This problem is solved by better stating what <code>view</code>, <code>over</code> and <code>set</code> need:</p>
<ul>
<li><p><code>view</code> only uses <code>Const</code> functor – so its type would be:</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb52-1"><a href="#cb52-1"></a><span class="co">-- old type:</span></span>
<span id="cb52-2"><a href="#cb52-2"></a><span class="co">--      ((a -&gt;    f    a) -&gt; s -&gt;    f    s) -&gt; s -&gt; a</span></span>
<span id="cb52-3"><a href="#cb52-3"></a><span class="ot">view ::</span> ((a <span class="ot">-&gt;</span> <span class="dt">Const</span> a a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Const</span> a s) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a</span></code></pre></div></li>
<li><p><code>over</code> and <code>set</code> use <code>Identity</code> functor:</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb53-1"><a href="#cb53-1"></a><span class="co">-- old type:</span></span>
<span id="cb53-2"><a href="#cb53-2"></a><span class="co">--      ((a -&gt;     f    b) -&gt; s -&gt;     f    t) -&gt; (a -&gt; b) -&gt; s -&gt; t</span></span>
<span id="cb53-3"><a href="#cb53-3"></a><span class="ot">over ::</span> ((a <span class="ot">-&gt;</span> <span class="dt">Identity</span> b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Identity</span> t) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> t</span></code></pre></div>
<p>(Not giving the type for <code>set</code> because it’s almost the same.)</p></li>
</ul>
<p>And now some convenient type synonyms (which mimic the ones in lens library):</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb54-1"><a href="#cb54-1"></a><span class="kw">type</span> <span class="dt">Getting</span> s a <span class="ot">=</span> (a <span class="ot">-&gt;</span> <span class="dt">Const</span> a a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Const</span> a s</span>
<span id="cb54-2"><a href="#cb54-2"></a></span>
<span id="cb54-3"><a href="#cb54-3"></a><span class="kw">type</span> <span class="dt">Setting</span> s t a b <span class="ot">=</span> (a <span class="ot">-&gt;</span> <span class="dt">Identity</span> b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Identity</span> t</span></code></pre></div>
<p>Again: previously we were requiring the lens to work with <em>any</em> functor, even tho we only used <code>Const</code> and <code>Identity</code> functors. Now we only ask for what we actually use, which means that <code>view</code> and <code>over</code> can work with <em>more</em> types of lenses now.</p>
<p>Applying these type synonyms to the signatures gives us:</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb55-1"><a href="#cb55-1"></a><span class="ot">view ::</span> <span class="dt">Getting</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a</span>
<span id="cb55-2"><a href="#cb55-2"></a><span class="ot">over ::</span> <span class="dt">Setting</span> s t a b <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> t</span>
<span id="cb55-3"><a href="#cb55-3"></a><span class="ot">set  ::</span> <span class="dt">Setting</span> s t a b <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> t</span></code></pre></div>
<p>With these modifications, we can finally apply <code>set</code> to <code>_all'</code>:</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb56-1"><a href="#cb56-1"></a><span class="op">&gt;</span> set (_all&#39; <span class="dv">0</span>) (<span class="op">-</span><span class="dv">8</span>) [<span class="dv">100</span>, <span class="dv">600</span>, <span class="dv">0</span>, <span class="dv">200</span>, <span class="dv">0</span>]</span>
<span id="cb56-2"><a href="#cb56-2"></a>[<span class="dv">100</span>, <span class="dv">600</span>, <span class="op">-</span><span class="dv">8</span>, <span class="dv">200</span>, <span class="op">-</span><span class="dv">8</span>]</span></code></pre></div>
<p>(Oh, by the way, if your definitions of <code>&lt;%~</code> and <code>&lt;&lt;%~</code> are broken now, you’ll have to rewrite them.)</p>
<h2 id="the-view-mystery">The <code>view</code> mystery</h2>
<p>What about <code>view</code>? What do you think would happen if you tried to apply <em>it</em> to <code>_all'</code>? Here are the definitions of <code>_all'</code> and <code>view</code> again for your convenience:</p>
<div class="sourceCode" id="cb57"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb57-1"><a href="#cb57-1"></a><span class="ot">view ::</span> <span class="dt">Getting</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a</span>
<span id="cb57-2"><a href="#cb57-2"></a>view l <span class="ot">=</span> getConst <span class="op">.</span> l <span class="dt">Const</span></span>
<span id="cb57-3"><a href="#cb57-3"></a></span>
<span id="cb57-4"><a href="#cb57-4"></a><span class="ot">_all&#39; ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">AppLens&#39;</span> [a] a</span>
<span id="cb57-5"><a href="#cb57-5"></a>_all&#39; ref f s <span class="ot">=</span> T.traverse update s</span>
<span id="cb57-6"><a href="#cb57-6"></a>  <span class="kw">where</span></span>
<span id="cb57-7"><a href="#cb57-7"></a>    update old <span class="ot">=</span> <span class="kw">if</span> old <span class="op">==</span> ref <span class="kw">then</span> f old <span class="kw">else</span> <span class="fu">pure</span> old</span></code></pre></div>
<p>A-and here’s the result:</p>
<div class="sourceCode" id="cb58"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb58-1"><a href="#cb58-1"></a><span class="op">&gt;</span> view (_all&#39; <span class="dv">0</span>) [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>]</span>
<span id="cb58-2"><a href="#cb58-2"></a></span>
<span id="cb58-3"><a href="#cb58-3"></a><span class="op">&lt;</span>interactive<span class="op">&gt;:</span></span>
<span id="cb58-4"><a href="#cb58-4"></a>    <span class="dt">No</span> <span class="kw">instance</span> for (<span class="dt">Data.Monoid.Monoid</span> a0) arising from a use <span class="kw">of</span> ‘it’</span>
<span id="cb58-5"><a href="#cb58-5"></a>    <span class="dt">The</span> <span class="kw">type</span> variable ‘a0’ is ambiguous</span>
<span id="cb58-6"><a href="#cb58-6"></a>    <span class="dt">Note</span><span class="op">:</span> there are several potential instances<span class="op">:</span></span>
<span id="cb58-7"><a href="#cb58-7"></a>      <span class="kw">instance</span> <span class="dt">Data.Monoid.Monoid</span> a <span class="ot">=&gt;</span> <span class="dt">Data.Monoid.Monoid</span> (<span class="dt">Const</span> a b)</span>
<span id="cb58-8"><a href="#cb58-8"></a>        <span class="co">-- Defined in ‘Control.Applicative’</span></span>
<span id="cb58-9"><a href="#cb58-9"></a>      <span class="kw">instance</span> <span class="dt">Data.Monoid.Monoid</span> () <span class="co">-- Defined in ‘Data.Monoid’</span></span>
<span id="cb58-10"><a href="#cb58-10"></a>      <span class="kw">instance</span> (<span class="dt">Data.Monoid.Monoid</span> a, <span class="dt">Data.Monoid.Monoid</span> b) <span class="ot">=&gt;</span></span>
<span id="cb58-11"><a href="#cb58-11"></a>               <span class="dt">Data.Monoid.Monoid</span> (a, b)</span>
<span id="cb58-12"><a href="#cb58-12"></a>        <span class="co">-- Defined in ‘Data.Monoid’</span></span>
<span id="cb58-13"><a href="#cb58-13"></a>      <span class="op">...</span>plus <span class="dv">16</span> others</span></code></pre></div>
<p>Oops. Okay, let’s look at the inferred type:</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb59-1"><a href="#cb59-1"></a><span class="op">&gt;</span> <span class="op">:</span>t view (_all&#39; <span class="dv">0</span>) [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>]</span>
<span id="cb59-2"><a href="#cb59-2"></a>view (_all&#39; <span class="dv">0</span>) [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>]<span class="ot"> ::</span> (<span class="dt">Data.Monoid.Monoid</span> a, <span class="dt">Num</span> a, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> a</span></code></pre></div>
<p><code>Monoid</code>? Where does it come from? Remember, the original <code>_all</code> worked just fine:</p>
<div class="sourceCode" id="cb60"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb60-1"><a href="#cb60-1"></a><span class="op">&gt;</span> view (_all <span class="dv">0</span>) [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>]</span>
<span id="cb60-2"><a href="#cb60-2"></a><span class="dv">0</span></span>
<span id="cb60-3"><a href="#cb60-3"></a></span>
<span id="cb60-4"><a href="#cb60-4"></a><span class="op">&gt;</span> <span class="op">:</span>t view (_all <span class="dv">0</span>) [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>]</span>
<span id="cb60-5"><a href="#cb60-5"></a>view (_all <span class="dv">0</span>) [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>]<span class="ot"> ::</span> (<span class="dt">Num</span> a, <span class="dt">Eq</span> a) <span class="ot">=&gt;</span> a</span></code></pre></div>
<h2 id="the-mystery-explained-exploiting-monoid">The mystery explained / exploiting <code>Monoid</code></h2>
<p>Take another look at the <a href="http://hackage.haskell.org/package/base/docs/Control-Applicative.html#v:Const"><code>Const</code></a> docs:</p>
<blockquote>
<p>Instances:</p>
<ul>
<li><code>Functor (Const m)</code></li>
<li><strong><code>Monoid m =&gt; Applicative (Const m)</code></strong></li>
<li><code>Foldable (Const m)</code></li>
<li><code>Traversable (Const m)</code></li>
<li><code>Generic1 (Const a)</code></li>
<li><code>Generic (Const a b)</code></li>
<li><code>Monoid a =&gt; Monoid (Const a b)</code></li>
<li><code>type Rep1 (Const a)</code></li>
<li><code>type Rep (Const a b)</code></li>
</ul>
</blockquote>
<p>The original <code>_all</code> was satisfied with <code>Functor</code>; <code>_all'</code> uses <code>Applicative</code>, and it implies a constraint on the type of <code>Const</code>’s parameter. Since numbers generally aren’t instances of <code>Monoid</code>, let’s try something else. What about a list of lists?</p>
<div class="sourceCode" id="cb61"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb61-1"><a href="#cb61-1"></a><span class="op">&gt;</span> view (_all&#39; [<span class="dv">0</span>]) [[<span class="dv">0</span>], [<span class="dv">1</span>], [<span class="dv">2</span>], [<span class="dv">0</span>]]</span>
<span id="cb61-2"><a href="#cb61-2"></a>[<span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb61-3"><a href="#cb61-3"></a></span>
<span id="cb61-4"><a href="#cb61-4"></a><span class="op">&gt;</span> view (_all&#39; [<span class="dv">0</span>]) [[<span class="dv">1</span>], [<span class="dv">2</span>]]</span>
<span id="cb61-5"><a href="#cb61-5"></a>[]</span></code></pre></div>
<p>A-ha, so <em>this</em> is how we can find out what values <code>_all'</code> is operating on. To make this more convenient, let’s define 2 helper functions – <code>toListOf</code> (to get all values) and <code>preview</code> (to get just the first value). Additionally, I’d like to be able to check whether there is <em>any</em> value to operate on, so I also want to write <code>has</code>.</p>
<h3 id="tolistof-all-values"><code>toListOf</code> = all values</h3>
<p>To write <code>toListOf</code>, look at <code>view</code> again:</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb62-1"><a href="#cb62-1"></a><span class="co">-- unexpanded type:</span></span>
<span id="cb62-2"><a href="#cb62-2"></a><span class="co">--                   Getting s a             -&gt; s -&gt; a</span></span>
<span id="cb62-3"><a href="#cb62-3"></a><span class="ot">view ::</span> ((a <span class="ot">-&gt;</span> <span class="dt">Const</span> a a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Const</span> a s) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a</span>
<span id="cb62-4"><a href="#cb62-4"></a>view l <span class="ot">=</span> getConst <span class="op">.</span> l <span class="dt">Const</span></span></code></pre></div>
<p>When <code>view</code> is applied to <code>_all'</code>, the <code>Monoid</code> instance for <code>Const a</code> comes into play – but <code>a</code>s in general can’t be combined meaningfully, and so it fails. (We can’t define a generic <code>Monoid</code> instance for any <code>a</code> – it’s impossible to write a generic <code>mempty :: Monoid a =&gt; a</code>, because it would have to pull an <code>a</code> out of thin air.) We can, however, trivially wrap <code>a</code> into a monoid (<code>[]</code> in this case):</p>
<div class="sourceCode" id="cb63"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb63-1"><a href="#cb63-1"></a><span class="ot">toListOf ::</span> ((a <span class="ot">-&gt;</span> <span class="dt">Const</span> [a] a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Const</span> [a] s) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> [a]</span>
<span id="cb63-2"><a href="#cb63-2"></a>toListOf l <span class="ot">=</span> getConst <span class="op">.</span> l (\x <span class="ot">-&gt;</span> <span class="dt">Const</span> [x])</span></code></pre></div>
<p>Then <code>[x]</code>s would be combined by the <code>Applicative</code> instance of <code>Const [a]</code>, and the result would contain all matching values in the list:</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb64-1"><a href="#cb64-1"></a><span class="op">&gt;</span> toListOf (_all&#39; <span class="dv">0</span>) [<span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">0</span>]</span>
<span id="cb64-2"><a href="#cb64-2"></a>[<span class="dv">0</span>,<span class="dv">0</span>]</span>
<span id="cb64-3"><a href="#cb64-3"></a></span>
<span id="cb64-4"><a href="#cb64-4"></a><span class="op">&gt;</span> toListOf (_all&#39; <span class="dv">0</span>) []</span>
<span id="cb64-5"><a href="#cb64-5"></a>[]</span></code></pre></div>
<h3 id="preview-first-value"><code>preview</code> = first value</h3>
<p><code>preview</code> is based on the same idea – using an appropriate monoid to get -the answer we want- out of combined <code>Const</code>s. This time, however, we’re only interested in the <em>first</em> value, not all of them. We could write our own monoid specifically for keeping the first value…</p>
<div class="sourceCode" id="cb65"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb65-1"><a href="#cb65-1"></a><span class="co">-- “Maybe a” because what if there aren&#39;t *any* values?</span></span>
<span id="cb65-2"><a href="#cb65-2"></a><span class="kw">data</span> <span class="dt">First</span> a <span class="ot">=</span> <span class="dt">First</span> (<span class="dt">Maybe</span> a)</span>
<span id="cb65-3"><a href="#cb65-3"></a></span>
<span id="cb65-4"><a href="#cb65-4"></a><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">First</span> a) <span class="kw">where</span></span>
<span id="cb65-5"><a href="#cb65-5"></a>  <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">First</span> <span class="dt">Nothing</span></span>
<span id="cb65-6"><a href="#cb65-6"></a></span>
<span id="cb65-7"><a href="#cb65-7"></a>  <span class="fu">mappend</span> (<span class="dt">First</span> <span class="dt">Nothing</span>) y <span class="ot">=</span> y</span>
<span id="cb65-8"><a href="#cb65-8"></a>  <span class="fu">mappend</span>        x        _ <span class="ot">=</span> x</span></code></pre></div>
<p>…but it turns out it has been written already as <a href="http://hackage.haskell.org/package/base/docs/Data-Monoid.html#t:First"><code>First</code></a> in the <code>Data.Monoid</code> module. Terrific.</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb66-1"><a href="#cb66-1"></a>preview</span>
<span id="cb66-2"><a href="#cb66-2"></a><span class="ot">  ::</span> ((a <span class="ot">-&gt;</span> <span class="dt">Const</span> (<span class="dt">First</span> a) a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Const</span> (<span class="dt">First</span> a) s)</span>
<span id="cb66-3"><a href="#cb66-3"></a>  <span class="ot">-&gt;</span> s</span>
<span id="cb66-4"><a href="#cb66-4"></a>  <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb66-5"><a href="#cb66-5"></a>preview l <span class="ot">=</span> getFirst <span class="op">.</span> getConst <span class="op">.</span> l (\x <span class="ot">-&gt;</span> <span class="dt">Const</span> (<span class="dt">First</span> (<span class="dt">Just</span> x)))</span></code></pre></div>
<p>Just in case you want to see it in action:</p>
<div class="sourceCode" id="cb67"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb67-1"><a href="#cb67-1"></a><span class="op">&gt;</span> preview (_all&#39; <span class="dv">0</span>) [<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">0</span>]</span>
<span id="cb67-2"><a href="#cb67-2"></a><span class="dt">Just</span> <span class="dv">0</span></span>
<span id="cb67-3"><a href="#cb67-3"></a></span>
<span id="cb67-4"><a href="#cb67-4"></a><span class="op">&gt;</span> preview (_all&#39; <span class="dv">0</span>) []</span>
<span id="cb67-5"><a href="#cb67-5"></a><span class="dt">Nothing</span></span></code></pre></div>
<h3 id="has-check-for-value"><code>has</code> = check for value</h3>
<p>Now, <code>has</code> shall return a mere <code>Bool</code>. Yep, we could act on the output of <code>preview</code> (just check whether it’s <code>Nothing</code> or <code>Just _</code>), but why do it when there’s a monoid already available? In particular, I’m talking about the <a href="http://hackage.haskell.org/package/base/docs/Data-Monoid.html#t:Any"><code>Any</code></a> monoid, which is a simple wrapper over <code>Bool</code>:</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb68-1"><a href="#cb68-1"></a><span class="kw">newtype</span> <span class="dt">Any</span> <span class="ot">=</span> <span class="dt">Any</span> <span class="dt">Bool</span></span></code></pre></div>
<p>With <code>Any</code> at hand, we can write <code>has</code> using the familiar pattern:</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb69-1"><a href="#cb69-1"></a><span class="ot">has ::</span> ((a <span class="ot">-&gt;</span> <span class="dt">Const</span> <span class="dt">Any</span> a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Const</span> <span class="dt">Any</span> s) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb69-2"><a href="#cb69-2"></a>has l <span class="ot">=</span> getAny <span class="op">.</span> getConst <span class="op">.</span> l (\_ <span class="ot">-&gt;</span> <span class="dt">Const</span> (<span class="dt">Any</span> <span class="dt">True</span>))</span></code></pre></div>
<div class="sourceCode" id="cb70"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb70-1"><a href="#cb70-1"></a><span class="op">&gt;</span> has (_all&#39; <span class="dv">0</span>) [<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">0</span>]</span>
<span id="cb70-2"><a href="#cb70-2"></a><span class="dt">True</span></span>
<span id="cb70-3"><a href="#cb70-3"></a></span>
<span id="cb70-4"><a href="#cb70-4"></a><span class="op">&gt;</span> has (_all&#39; <span class="dv">0</span>) [<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>]</span>
<span id="cb70-5"><a href="#cb70-5"></a><span class="dt">False</span></span></code></pre></div>
<h3 id="no-clumsy-types">No clumsy types!</h3>
<p>Don’t you think the types of functions we’ve written are kinda overly long? They’re the same as the original <code>Getting s a</code></p>
<div class="sourceCode" id="cb71"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb71-1"><a href="#cb71-1"></a><span class="kw">type</span> <span class="dt">Getting</span> s a <span class="ot">=</span> (a <span class="ot">-&gt;</span> <span class="dt">Const</span> a a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Const</span> a s</span></code></pre></div>
<p>with various monoids in place of <code>a</code> in <code>Const a</code>. Why not simply add an additional parameter to <code>Getting</code>?</p>
<div class="sourceCode" id="cb72"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb72-1"><a href="#cb72-1"></a><span class="kw">type</span> <span class="dt">Getting</span> r s a <span class="ot">=</span> (a <span class="ot">-&gt;</span> <span class="dt">Const</span> r a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Const</span> r s</span></code></pre></div>
<p>A-ha, this way it’s much better (and also more similar to the actual types from lens):</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb73-1"><a href="#cb73-1"></a><span class="ot">view     ::</span> <span class="dt">Getting</span>  a        s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a</span>
<span id="cb73-2"><a href="#cb73-2"></a><span class="ot">toListOf ::</span> <span class="dt">Getting</span> [a]       s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> [a]</span>
<span id="cb73-3"><a href="#cb73-3"></a><span class="ot">preview  ::</span> <span class="dt">Getting</span> (<span class="dt">First</span> a) s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb73-4"><a href="#cb73-4"></a><span class="ot">has      ::</span> <span class="dt">Getting</span> <span class="dt">Any</span>       s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Bool</span></span></code></pre></div>
<p>To make it easier to remember, here’s what <code>Getting</code> approximately means in English:</p>
<blockquote>
<p><code>Getting r s a</code> is a function which, given some way to get <code>r</code> from <code>a</code>, will go over <code>a</code>s in some <code>s</code> and return their combined <code>r</code>s.</p>
</blockquote>
<p>Or you could keep in mind that <code>Const r a</code> is the same as <code>r</code>, and mentally simplify the type to</p>
<div class="sourceCode" id="cb74"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb74-1"><a href="#cb74-1"></a><span class="kw">type</span> <span class="dt">Getting</span> r s a <span class="ot">=</span> (a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> r</span></code></pre></div>
<p>(and then <code>Setting s t a b</code> is simply <code>(a -&gt; b) -&gt; s -&gt; t</code>.)</p>
<h3 id="why-all-this-when-tolistof-is-enough">Why all this when <code>toListOf</code> is enough?</h3>
<p>There’s no single definite reason for not implementing everything in terms of <code>toListOf</code> once we have it, but…</p>
<ul>
<li><p>It would be “pretty odd” (as I got told on #haskell-lens).</p></li>
<li><p>It would probably be slower.</p></li>
<li><p>Aw c’mon, they’re all one-liners anyway.</p></li>
</ul>
<h2 id="tolistof-is-subtly-broken"><code>toListOf</code> is subtly broken</h2>
<p>(I mean, if you haven’t noticed it already. Otherwise it’s “obviously broken”.)</p>
<p>Look at the definition of <code>toListOf</code> again:</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb75-1"><a href="#cb75-1"></a>toListOf l <span class="ot">=</span> getConst <span class="op">.</span> l (\x <span class="ot">-&gt;</span> <span class="dt">Const</span> [x])</span></code></pre></div>
<p>Notice that we always create a list consisting of 1 element. That’s a million billion lists in case of a structure consisting of a million billion elements. All those lists would have to be <em>concatenated</em>. Are you starting to realise?</p>
<p>In case of the “structure” being a list, it doesn’t matter – <code>traverse</code> would do the appends in the right order</p>
<div class="sourceCode" id="cb76"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb76-1"><a href="#cb76-1"></a>[<span class="dv">1</span>] <span class="op">++</span> ([<span class="dv">2</span>] <span class="op">++</span> ([<span class="dv">3</span>] <span class="op">++</span> ([<span class="dv">4</span>] <span class="op">++</span> <span class="op">...</span></span></code></pre></div>
<p>and the whole operation would be cheap. However, it does matter when we’re working with trees. Imagine a tree with 2 branches, one completely left-biased, the other – right-biased:</p>
<pre><code>            __0__
           /     \
          1       1
         / \     / \
        2   0   0   2
       / \         / \
      3   0       0   3
     / \             / \
    4   0           0   4
   / \                 / \
  .....               .....</code></pre>
<p>Let’s say we cut this tree at depth 4 and do a traversal. Here are the appends that would happen (excluding appends to empty lists):</p>
<ul>
<li><strong><code>[4] &lt;&gt; [0]</code></strong></li>
<li><code>[3] &lt;&gt; [4,0]</code></li>
<li><strong><code>[3,4,0] &lt;&gt; [0]</code></strong></li>
<li><code>[2] &lt;&gt; [3,4,0,0]</code></li>
<li><strong><code>[2,3,4,0,0] &lt;&gt; [0]</code></strong></li>
<li><code>[1] &lt;&gt; [2,3,4,0,0,0]</code></li>
<li><code>[0] &lt;&gt; [4]</code></li>
<li><code>[3] &lt;&gt; [0,4]</code></li>
<li><code>[0] &lt;&gt; [3,0,4]</code></li>
<li><code>[2] &lt;&gt; [0,3,0,4]</code></li>
<li><code>[0] &lt;&gt; [2,0,3,0,4]</code></li>
<li><code>[1] &lt;&gt; [0,2,0,3,0,4]</code></li>
<li><strong><code>[1,2,3,4,0,0,0] &lt;&gt; [1,0,2,0,3,0,4]</code></strong></li>
<li><code>[0] &lt;&gt; [1,2,3,4,0,0,0,1,0,2,0,3,0,4]</code></li>
</ul>
<p>Generally, for such a tree of depth N (and containing O(N) elements), there are N “bold” appends – the i-th append takes O(i) time, and the total runtime is O(N<sup>2</sup>) for O(N) elements. Ba-a-ad.</p>
<h3 id="difference-lists">Difference lists</h3>
<p>There’s a well-known technique for making each append O(1) when you have to do a lot of them, and it’s called <em>difference lists</em>. I find existing explanations (e.g. in <a href="http://book.realworldhaskell.org/read/data-structures.html#data.dlist">Real World Haskell</a> and on <a href="http://stackoverflow.com/a/13879693/615030">StackOverflow</a>) slightly confusing, so I’ll explain it myself.</p>
<p>When we have a complex sequence of appends</p>
<div class="sourceCode" id="cb78"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb78-1"><a href="#cb78-1"></a>(((<span class="st">&quot;a&quot;</span> <span class="op">++</span> <span class="st">&quot;b&quot;</span>) <span class="op">++</span> <span class="st">&quot;c&quot;</span>) <span class="op">++</span> ((<span class="st">&quot;d&quot;</span> <span class="op">++</span> <span class="st">&quot;e&quot;</span>) <span class="op">++</span> <span class="st">&quot;f&quot;</span>) <span class="op">++</span> (<span class="st">&quot;g&quot;</span> <span class="op">++</span> <span class="st">&quot;h&quot;</span>)) <span class="op">++</span> <span class="op">...</span></span></code></pre></div>
<p>what we’d like is to somehow get a list of the “stuff being appended” and just do <code>concat</code> on it. The first idea is to append not lists, but <em>lists</em> of lists</p>
<div class="sourceCode" id="cb79"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb79-1"><a href="#cb79-1"></a><span class="kw">type</span> <span class="dt">ConcatList</span> a <span class="ot">=</span> [[a]]</span>
<span id="cb79-2"><a href="#cb79-2"></a></span>
<span id="cb79-3"><a href="#cb79-3"></a><span class="ot">(+|+) ::</span> <span class="dt">ConcatList</span> a <span class="ot">-&gt;</span> <span class="dt">ConcatList</span> a <span class="ot">-&gt;</span> <span class="dt">ConcatList</span> a</span>
<span id="cb79-4"><a href="#cb79-4"></a>(<span class="op">+|+</span>) a b <span class="ot">=</span> a <span class="op">++</span> b</span></code></pre></div>
<p>and concat them all in the end:</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb80-1"><a href="#cb80-1"></a><span class="ot">toList ::</span> <span class="dt">ConcatList</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="cb80-2"><a href="#cb80-2"></a>toList <span class="ot">=</span> <span class="fu">concat</span></span></code></pre></div>
<p>But this approach, of course, won’t work, as it doesn’t make any difference when all “elementary” lists are a single element each. What we’d <em>really</em> like is to just say “these 2 lists have to go one after the other” and store this information without actually appending them yet… wait, we can do that with Haskell’s data types!</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb81-1"><a href="#cb81-1"></a><span class="kw">data</span> <span class="dt">AppendList</span> a <span class="ot">=</span> <span class="dt">Append</span> [a] [a]</span></code></pre></div>
<p>Pfft, just kidding, this won’t work. First of all, we want to append not simple, ordinary lists, but our <code>AppendList</code>s:</p>
<div class="sourceCode" id="cb82"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb82-1"><a href="#cb82-1"></a><span class="kw">data</span> <span class="dt">AppendList</span> a <span class="ot">=</span> <span class="dt">Append</span> (<span class="dt">AppendList</span> a) (<span class="dt">AppendList</span> a)</span></code></pre></div>
<p>Then, where would <em>actual values</em> be stored? Let’s add another constructor specifically for them:</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb83-1"><a href="#cb83-1"></a><span class="kw">data</span> <span class="dt">AppendList</span> a <span class="ot">=</span> <span class="dt">JustList</span> [a] <span class="op">|</span> <span class="dt">Append</span> (<span class="dt">AppendList</span> a) (<span class="dt">AppendList</span> a)</span></code></pre></div>
<p>We don’t need a special function for appending, because it’s simply <code>Append</code>. But getting a list out of <code>AppendList</code> is slightly tricky:</p>
<div class="sourceCode" id="cb84"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb84-1"><a href="#cb84-1"></a><span class="ot">doAppends ::</span> <span class="dt">AppendList</span> a <span class="ot">-&gt;</span> [a]</span>
<span id="cb84-2"><a href="#cb84-2"></a>doAppends (<span class="dt">JustList</span> x) <span class="ot">=</span> x</span>
<span id="cb84-3"><a href="#cb84-3"></a>doAppends (<span class="dt">Append</span> x y) <span class="ot">=</span> <span class="op">...</span></span></code></pre></div>
<p>Recursively converting <code>x</code> and <code>y</code> to lists and appending them with <code>++</code> wouldn’t work— well, it would, but it wouldn’t give any speed benefit. We need to <em>reorder</em> <code>(a ++ b) ++ y ++ ...</code> into <code>a ++ (b ++ y ++ ...)</code>, remember? So, let’s match on <code>x</code> as well:</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb85-1"><a href="#cb85-1"></a>doAppends (<span class="dt">Append</span> (<span class="dt">JustList</span> x) y) <span class="ot">=</span> x <span class="op">++</span> doAppends y</span>
<span id="cb85-2"><a href="#cb85-2"></a>doAppends (<span class="dt">Append</span> (<span class="dt">Append</span> a b) y) <span class="ot">=</span> doAppends (<span class="dt">Append</span> a (<span class="dt">Append</span> b y))</span></code></pre></div>
<p>I won’t show the benchmarks here – you can do some by yourself if you want (in a nutshell: use <a href="http://hackage.haskell.org/package/containers/docs/Data-Tree.html"><code>Data.Tree</code></a>, generate the “evil tree” recursively, make a <code>Monoid</code> instance for <code>AppendList</code>, and use <code>traverse</code> with <code>Const (AppendList a)</code> to flatten it; to measure time in GHCi, do <code>:set +s</code> (I always confused <code>s</code> and <code>t</code> until I learned that <code>s</code> stands for “statistics”)). But I’ll tell you the results: an <code>AppendList</code>-based traversal is linear in time, while <code>[]</code>-based one is quadratic; the former flattens a tree of depth 2000k in 20s, while the latter only handles the depth of 11k in this time. [Just in case, “k” means “thousand” and not anything else it could mean.]</p>
<p>Now we can rewrite <code>toListOf</code> using <code>AppendList</code>:</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb86-1"><a href="#cb86-1"></a><span class="kw">instance</span> <span class="dt">Monoid</span> (<span class="dt">AppendList</span> a) <span class="kw">where</span></span>
<span id="cb86-2"><a href="#cb86-2"></a>  <span class="fu">mempty</span> <span class="ot">=</span> <span class="dt">JustList</span> []</span>
<span id="cb86-3"><a href="#cb86-3"></a>  <span class="fu">mappend</span> <span class="ot">=</span> <span class="dt">Append</span></span>
<span id="cb86-4"><a href="#cb86-4"></a></span>
<span id="cb86-5"><a href="#cb86-5"></a><span class="ot">toListOf ::</span> <span class="dt">Getting</span> (<span class="dt">AppendList</span> a) s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> [a]</span>
<span id="cb86-6"><a href="#cb86-6"></a>toListOf l <span class="ot">=</span> doAppends <span class="op">.</span> getConst <span class="op">.</span> l (\x <span class="ot">-&gt;</span> <span class="dt">Const</span> (<span class="dt">JustList</span> [x]))</span></code></pre></div>
<h3 id="actual-difference-lists">Actual difference lists</h3>
<p>…This is getting slightly offtopic, so I’ll try to be more concise now.</p>
<p>A cool thing is that the compiler already does this reordering-stuff – when it simplifies expressions. Let’s say we’re evaluating <code>(x ++ y) ++ z</code>:</p>
<ul>
<li><p>The second <code>++</code> says: “let me look at the first element of <code>x ++ y</code> – if it exists, I’ll emit it”.</p></li>
<li><p>The first <code>++</code> says: “let me look at the first element of <code>x</code>”.</p></li>
<li><p>Then it passes the element to the outer <code>++</code>.</p></li>
<li><p>Then the outer <code>++</code> emits it and proceeds with the second element.</p></li>
</ul>
<p>After all this, <em>each</em> element of <code>x</code> is “looked at” twice.</p>
<p>Now consider this alternative way to construct <code>(x ++ y) ++ z</code> using functions – <code>((x ++) . (y ++)) . (z ++) $ []</code> (I just replaced each list with a function that appends this list to the argument). When evaluating <em>this</em> expression, the compiler will have to expand some <code>.</code> – and after this expansion the “application tree” would be practically flat! To understand better, you really should watch the succession of steps done by <a href="http://bm380.user.srcf.net/cgi-bin/stepeval.cgi?expr=%28%28%5Ba%2Cb%5D+%2B%2B%29+.+%28%5Bc%2Cd%5D+%2B%2B%29%29+.+%28%5Be%2Cf%5D+%2B%2B%29+%24+%5B%5D">stepeval</a>, and then look at <a href="http://h2.jaguarpaw.co.uk:24680/posts/demystifying-dlist/#improving-performance">these pictures</a>. I’ve replicated the <code>stepeval</code> output here for your convenience, with bogus steps (e.g. <code>[a]</code> being “evaluated” into <code>a : []</code>) omitted. First, the normal version:</p>
<blockquote>
<ul>
<li><code>([a, b] ++ [c, d]) ++ [e, f]</code></li>
<li><code>(a : [b] ++ [c, d]) ++ [e, f]</code> ← Here <code>a</code> has gone thru the first <code>++</code>…</li>
<li><code>a : ([b] ++ [c, d]) ++ [e, f]</code> ← …and only here – thru the second.</li>
<li><code>a : (b : [] ++ [c, d]) ++ [e, f]</code> ← Same with <code>b</code> –</li>
<li><code>a : b : ([] ++ [c, d]) ++ [e, f]</code> ← there are as many steps as <code>++</code>s.</li>
<li><code>a : b : [c, d] ++ [e, f]</code></li>
<li><code>a : b : c : [d] ++ [e, f]</code> ← Only 1 step for <code>c</code>.</li>
<li><code>a : b : c : d : [] ++ [e, f]</code> ← Same with <code>d</code>.</li>
<li><code>a : b : c : d : e : f : []</code></li>
</ul>
</blockquote>
<p>And now, the “difference list” version, which gets transformed into plain <code>[a, b] ++ [c, d] ++ [e, f]</code> (if you strip the extraneous parens) after only 3 steps:</p>
<blockquote>
<ul>
<li><code>(([a, b] ++) . ([c, d] ++)) . ([e, f] ++) $ []</code></li>
<li><code>((([a, b] ++) . ([c, d] ++)) . ([e, f] ++)) []</code></li>
<li><code>(([a, b] ++) . ([c, d] ++)) (([e, f] ++) [])</code> ← Removed one <code>.</code>.</li>
<li><code>([a, b] ++) (([c, d] ++) (([e, f] ++) []))</code> ← Removed another <code>.</code>.</li>
<li><code>a : [b] ++ ([c, d] ++) (([e, f] ++) [])</code> ← Okay, here comes <code>a</code> already.</li>
<li><code>a : b : [] ++ ([c, d] ++) (([e, f] ++) [])</code></li>
<li><code>a : b : ([c, d] ++) (([e, f] ++) [])</code></li>
<li><code>a : b : c : [d] ++ ([e, f] ++) []</code></li>
<li><code>a : b : c : d : [] ++ ([e, f] ++) []</code></li>
<li><code>a : b : c : d : ([e, f] ++) []</code></li>
<li><code>a : b : c : d : e : [f] ++ []</code></li>
<li><code>a : b : c : d : e : f : [] ++ []</code></li>
<li><code>a : b : c : d : e : f : []</code></li>
</ul>
</blockquote>
<p>The important thing is that with difference lists we have to do only as many preliminary steps as there are lists to append; after that each element is generated in constant time. With ordinary lists, each element takes the time proportional to its depth in the tree – and this leads to quadratic behavior.</p>
<p>In case you’re wondering, differential lists from the <code>Data.DList</code> module are twice as fast as our handwritten <code>AppendList</code>.</p>
<h3 id="introducing-monoids.-of-endomorphisms-under-composition">Introducing… monoids. Of endomorphisms! Under composition!</h3>
<p>Turns out, however, that we don’t even need the full power of difference lists. <code>Data.Monoid</code> includes a very simple version that’s enough for our purpose – <a href="http://hackage.haskell.org/package/base/docs/Data-Monoid.html#t:Endo"><code>Endo</code></a>, which is, as the documentation helpfully suggests, “the monoid of endomorphisms under composition”. (As a side note, when I’m the king of Earth and its surroundings, I shall assemble a team of technical writers and bring all documentation in standard libraries to the level of <a href="http://hackage.haskell.org/package/pipes/docs/Pipes-Tutorial.html">pipes</a>.)</p>
<p>Translated into <del>humanese</del> <del>English</del> language that -people who haven’t studied category theory and don’t really like googling- can understand, <code>Endo</code> is a <code>newtype</code> wrapper that lets us use the fact that functions of type <code>a -&gt; a</code> form a monoid. (One reason why a wrapper is needed is that functions of the type <code>Monoid b =&gt; a -&gt; b</code>, too, form a monoid – the same type can’t have 2 instances of the same typeclass, and this instance is more important than the <code>Endo</code> one.) What monoid? Well, <code>id</code> is the identity element, and <code>.</code> is the binary operation, nothing interesting.</p>
<p>Have you guessed already how it can be used? With difference lists, each “list” looks like <code>(x ++)</code> – which has the type <code>[a] -&gt; [a]</code>. It’s an endomorphism! And we use <code>.</code> to append lists… and <code>.</code> is also function composition! Wow!</p>
<p>Um, I’m sorry for using 3 exclamation marks in a paragraph. I just thought it would make the text a bit less dull. (At night, many things seem duller than they are, and it’s 2.30am here at the moment of writing.)</p>
<p>[Oh, and I’m also sorry for being meta in the last paragraph. I’ve noticed that some people are confounded by anything meta (especially in a conversation, for some reason); if you’re one of those people, please accept my <del>condolences</del> apologies.]</p>
<p>Anyway, the final version of <code>toListOf</code> looks like this:</p>
<div class="sourceCode" id="cb87"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb87-1"><a href="#cb87-1"></a><span class="ot">toListOf ::</span> <span class="dt">Getting</span> (<span class="dt">Endo</span> [a]) s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> [a]</span>
<span id="cb87-2"><a href="#cb87-2"></a>toListOf l <span class="ot">=</span> (<span class="ot">`appEndo`</span> []) <span class="op">.</span> getConst <span class="op">.</span> l (\x <span class="ot">-&gt;</span> <span class="dt">Const</span> (<span class="dt">Endo</span> (x<span class="op">:</span>)))</span></code></pre></div>
<p>(<code>x:</code> looks better than <code>[x] ++</code>, don’t you think? On the other hand, <code>(`appEndo` [])</code> looks worse than <code>toList</code> or <code>doAppends</code>. Whatever.)</p>
<p>Well, it’s not <em>actually</em> final – in the next part of this series I’ll have explained enough to match the true implementation in lens,</p>
<div class="sourceCode" id="cb88"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb88-1"><a href="#cb88-1"></a><span class="ot">toListOf ::</span> <span class="dt">Getting</span> (<span class="dt">Endo</span> [a]) s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> [a]</span>
<span id="cb88-2"><a href="#cb88-2"></a>toListOf l <span class="ot">=</span> foldrOf l (<span class="op">:</span>) []</span></code></pre></div>
<p>but at least the type signature is “final”, and we’ll have to be satisfied with that for the time being.</p>
<p>P.S. Did you know that originally lens used <code>[a]</code>, and it was only <a href="https://github.com/ekmett/lens/issues/105">changed to <code>Endo [a]</code></a> in version 3.4? It helped me realise that lens isn’t a shiny piece of perfect abstractions where everything follows absolutely rigorously from everything else and there’s only one way to write things. Lens is alive. Lens is evolving. Some even <a href="http://ro-che.info/articles/2014-04-24-lens-unidiomatic">worry</a> it will become a “[new language] we all will have to learn […] sooner or later” – and when it happens, we shall be prepared. Right?</p>
<p>[Soon on /r/haskell: “Lens, Pipes and Yesod Break Free, Fight Amid the Ruins of Haskell! SPJ Disappointed”.]</p>
<h2 id="get-back-to-traversals-will-you">Get back to traversals, will you?</h2>
<p>Ouch, sorry. Our <code>AppLens</code> is actually called <a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#t:Traversal"><code>Traversal</code></a> in lens library! Here’s the All-New Rebranded Definition:</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb89-1"><a href="#cb89-1"></a><span class="kw">type</span> <span class="dt">Traversal</span> s t a b <span class="ot">=</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> f t</span>
<span id="cb89-2"><a href="#cb89-2"></a><span class="kw">type</span> <span class="dt">Traversal&#39;</span> s a <span class="ot">=</span> <span class="dt">Traversal</span> s s a a</span></code></pre></div>
<p>To celebrate this amazing revelation, here are some new <code>Traversal</code>s for you:</p>
<h2 id="each-every-element"><code>each</code> = every element</h2>
<p><a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Each.html#v:each"><code>each</code></a> focuses on every element in a monomorphic container:</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb90-1"><a href="#cb90-1"></a><span class="op">&gt;</span> set each <span class="dv">8</span> [<span class="dv">1</span><span class="op">..</span><span class="dv">3</span>]</span>
<span id="cb90-2"><a href="#cb90-2"></a>[<span class="dv">8</span>,<span class="dv">8</span>,<span class="dv">8</span>]</span>
<span id="cb90-3"><a href="#cb90-3"></a></span>
<span id="cb90-4"><a href="#cb90-4"></a><span class="op">&gt;</span> over each <span class="fu">toUpper</span> (Data.Text.pack <span class="st">&quot;blah&quot;</span>)</span>
<span id="cb90-5"><a href="#cb90-5"></a><span class="st">&quot;BLAH&quot;</span></span>
<span id="cb90-6"><a href="#cb90-6"></a></span>
<span id="cb90-7"><a href="#cb90-7"></a><span class="op">&gt;</span> each (\x <span class="ot">-&gt;</span> <span class="fu">print</span> x <span class="op">&gt;&gt;</span> <span class="fu">return</span> (<span class="op">-</span>x)) (<span class="dv">8</span>, <span class="dv">19</span>)</span>
<span id="cb90-8"><a href="#cb90-8"></a><span class="dv">8</span></span>
<span id="cb90-9"><a href="#cb90-9"></a><span class="dv">19</span></span>
<span id="cb90-10"><a href="#cb90-10"></a>(<span class="op">-</span><span class="dv">8</span>,<span class="op">-</span><span class="dv">19</span>)</span></code></pre></div>
<p>Its implementation is pretty simple. To support different types of containers, we create a typeclass containing <code>each</code> as its only method:</p>
<div class="sourceCode" id="cb91"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb91-1"><a href="#cb91-1"></a><span class="ot">{-# LANGUAGE</span></span>
<span id="cb91-2"><a href="#cb91-2"></a><span class="ot">  MultiParamTypeClasses, FlexibleInstances, FunctionalDependencies #-}</span></span>
<span id="cb91-3"><a href="#cb91-3"></a></span>
<span id="cb91-4"><a href="#cb91-4"></a><span class="kw">class</span> <span class="dt">Each</span> s t a b <span class="op">|</span> s <span class="ot">-&gt;</span> a, t <span class="ot">-&gt;</span> b, s b <span class="ot">-&gt;</span> t, t a <span class="ot">-&gt;</span> s <span class="kw">where</span></span>
<span id="cb91-5"><a href="#cb91-5"></a><span class="ot">  each ::</span> <span class="dt">Traversal</span> s t a b</span></code></pre></div>
<p>(The <code>s -&gt; a, ...</code> bit is a <a href="http://www.haskell.org/haskellwiki/Functional_dependencies">functional dependency</a> – without it we are going to get a bunch of “ambiguous type” errors whenever we try to actually use <code>each</code>).)</p>
<p>Now the best part: <code>each</code> is actually the <em>same</em> as <code>traverse</code>!</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb92-1"><a href="#cb92-1"></a><span class="kw">instance</span> <span class="dt">T.Traversable</span> t <span class="ot">=&gt;</span> <span class="dt">Each</span> (t a) (t b) a b <span class="kw">where</span></span>
<span id="cb92-2"><a href="#cb92-2"></a>  each <span class="ot">=</span> T.traverse</span></code></pre></div>
<p>Well, at least for <code>Traversable</code> types – that’s <code>[]</code>, <code>Map</code>, <code>Maybe</code>, and so on… Hm. Tuples are <code>Traversable</code> as well, right?</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb93-1"><a href="#cb93-1"></a><span class="op">&gt;</span> T.traverse (\_ <span class="ot">-&gt;</span> <span class="fu">putStr</span> <span class="st">&quot;? new: &quot;</span> <span class="op">&gt;&gt;</span><span class="ot"> readLn ::</span> <span class="dt">IO</span> <span class="dt">Bool</span>) (<span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb93-2"><a href="#cb93-2"></a><span class="op">?</span> new<span class="op">:</span> <span class="dt">True</span></span>
<span id="cb93-3"><a href="#cb93-3"></a>(<span class="dv">1</span>,<span class="dt">True</span>)</span></code></pre></div>
<p>Darn. So our <code>each</code> isn’t the same as lens’s <code>each</code> after all:</p>
<div class="sourceCode" id="cb94"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb94-1"><a href="#cb94-1"></a><span class="op">&gt;</span> set each <span class="dv">8</span> (<span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb94-2"><a href="#cb94-2"></a>(<span class="dv">1</span>,<span class="dv">8</span>)</span>
<span id="cb94-3"><a href="#cb94-3"></a></span>
<span id="cb94-4"><a href="#cb94-4"></a><span class="op">&gt;</span> set Control.Lens.each <span class="dv">8</span> (<span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb94-5"><a href="#cb94-5"></a>(<span class="dv">8</span>,<span class="dv">8</span>)</span></code></pre></div>
<p>Of course, now I could just explain how to write <code>each</code> correctly (even tho it’s pretty obvious and doesn’t really need any explanation), but instead I’ll dissect the actual <a href="http://hackage.haskell.org/package/lens/docs/src/Control-Lens-Each.html">implementation of <code>Each</code></a> in the lens library. “What a waste of time”, you might be thinking… Sorry.</p>
<h2 id="dissecting-each">Dissecting <code>Each</code></h2>
<p>The reason for our <code>each</code> being different from lens’s <code>each</code> is that the <code>Traversable</code> instance for tuples isn’t quite what we want – it’s more general (<code>Traversable ((,) a)</code>), but the price to pay is that <code>traverse</code> can only work with the second element. Just in case, here’s the definition:</p>
<div class="sourceCode" id="cb95"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb95-1"><a href="#cb95-1"></a><span class="kw">instance</span> <span class="dt">Traversable</span> ((,) a) <span class="kw">where</span></span>
<span id="cb95-2"><a href="#cb95-2"></a>  <span class="fu">traverse</span> f (x, y) <span class="ot">=</span> (x, ) <span class="op">&lt;$&gt;</span> f y</span></code></pre></div>
<p>(One reason – don’t know whether there are more – for -not having the seemingly more useful instance for <code>(a, a)</code> in the base- is that you can’t actually write it without resorting to newtypes, and this is because Haskell doesn’t have <a href="http://programmers.stackexchange.com/questions/177967/why-doesnt-haskell-have-type-level-lambda-abstractions">type-level lambdas</a>.)</p>
<p>So, <code>Traversable</code> doesn’t work as we want. No big deal, yeah – the only downside is that instead of a single instance like <code>Traversable t =&gt; Each ...</code>, there is:</p>
<ul>
<li><p>A kinda scary class declaration:</p>
<div class="sourceCode" id="cb96"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb96-1"><a href="#cb96-1"></a><span class="kw">class</span> <span class="dt">Each</span> s t a b <span class="op">|</span> s <span class="ot">-&gt;</span> a, t <span class="ot">-&gt;</span> b, s b <span class="ot">-&gt;</span> t, t a <span class="ot">-&gt;</span> s <span class="kw">where</span></span>
<span id="cb96-2"><a href="#cb96-2"></a><span class="ot">  each ::</span> <span class="dt">Traversal</span> s t a b</span>
<span id="cb96-3"><a href="#cb96-3"></a><span class="pp">#ifndef HLINT</span></span>
<span id="cb96-4"><a href="#cb96-4"></a>  default<span class="ot"> each ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Traversable</span> g, s <span class="op">~</span> g a, t <span class="op">~</span> g b)</span>
<span id="cb96-5"><a href="#cb96-5"></a>               <span class="ot">=&gt;</span> <span class="dt">LensLike</span> f s t a b</span>
<span id="cb96-6"><a href="#cb96-6"></a>  each <span class="ot">=</span> <span class="fu">traverse</span></span>
<span id="cb96-7"><a href="#cb96-7"></a>  <span class="ot">{-# INLINE each #-}</span></span>
<span id="cb96-8"><a href="#cb96-8"></a><span class="pp">#endif</span></span></code></pre></div></li>
<li><p>Several “default” instances without implementation:</p>
<div class="sourceCode" id="cb97"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb97-1"><a href="#cb97-1"></a><span class="kw">instance</span> <span class="dt">Each</span> [a] [b] a b</span>
<span id="cb97-2"><a href="#cb97-2"></a><span class="kw">instance</span> <span class="dt">Each</span> (<span class="dt">NonEmpty</span> a) (<span class="dt">NonEmpty</span> b) a b</span>
<span id="cb97-3"><a href="#cb97-3"></a><span class="kw">instance</span> <span class="dt">Each</span> (<span class="dt">Identity</span> a) (<span class="dt">Identity</span> b) a b</span>
<span id="cb97-4"><a href="#cb97-4"></a><span class="kw">instance</span> <span class="dt">Each</span> (<span class="dt">Maybe</span> a) (<span class="dt">Maybe</span> b) a b</span>
<span id="cb97-5"><a href="#cb97-5"></a><span class="kw">instance</span> <span class="dt">Each</span> (<span class="dt">Seq</span> a) (<span class="dt">Seq</span> b) a b</span>
<span id="cb97-6"><a href="#cb97-6"></a><span class="kw">instance</span> <span class="dt">Each</span> (<span class="dt">Tree</span> a) (<span class="dt">Tree</span> b) a b</span></code></pre></div></li>
<li><p>Other instances, such as the one for 2-tuples (there are similar ones up to 9-tuples there):</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb98-1"><a href="#cb98-1"></a><span class="kw">instance</span> (a<span class="op">~</span>a&#39;, b<span class="op">~</span>b&#39;) <span class="ot">=&gt;</span> <span class="dt">Each</span> (a,a&#39;) (b,b&#39;) a b <span class="kw">where</span></span>
<span id="cb98-2"><a href="#cb98-2"></a>  each f <span class="op">~</span>(a,b) <span class="ot">=</span> (,) <span class="op">&lt;$&gt;</span> f a <span class="op">&lt;*&gt;</span> f b</span>
<span id="cb98-3"><a href="#cb98-3"></a>  <span class="ot">{-# INLINE each #-}</span></span></code></pre></div></li>
</ul>
<h3 id="ifndef"><code>#ifndef</code></h3>
<p>Let’s start with the class declaration. The <code>#ifndef</code> section would be removed by the C preprocessor if the code is being analysed by <a href="http://community.haskell.org/~ndm/hlint/">HLint</a> at the moment; to see why, it’s enough to simply run HLint on this piece of code:</p>
<pre><code>/tmp/lens-each:3:3: Warning: Parse error: default
Found:
    class Each s t a b | s -&gt; a, t -&gt; b, s b -&gt; t, t a -&gt; s where
      each :: Traversal s t a b
  &gt;   default each :: (Applicative f, Traversable g, s ~ g a, t ~ g b)
                   =&gt; LensLike f s t a b
      each = traverse

1 suggestion</code></pre>
<p>Um, just so that it wouldn’t be left unexplained… In a nutshell:</p>
<ul>
<li><p>You can enable <code>{-# LANGUAGE CPP #-}</code> and get your source processed by the <a href="http://www.cprogramming.com/tutorial/cpreprocessor.html">C preprocessor</a>.</p></li>
<li><p>It’s mainly used to do things differently based on the version of the compiler, available libraries, OS, and so on.</p></li>
<li><p>I won’t describe how to use it yet (but I will when we stumble upon code which uses it more extensively). For now, you just need to know that <code>#ifndef</code> means “if not defined”, <code>HLINT</code> is the variable which would be in “defined” state when the code is processed by HLint.</p></li>
<li><p>Finally, it’s “<strong>C</strong> <strong>p</strong>re<strong>p</strong>rocessor”, not “<strong>C</strong> <strong>p</strong>lus <strong>p</strong>lus preprocessor”.</p></li>
</ul>
<h3 id="default"><code>default</code></h3>
<p>So we’ve learned that HLint doesn’t like this code because of <code>default</code>. Some googling shows us that <code>default</code> in type classes is enabled by the <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/glasgow_exts.html#extension-DefaultSignatures"><code>DefaultSignatures</code></a> extension, which HLint apparently isn’t yet aware of. If you aren’t aware of it either – again, here’s an “in a nutshell” explanation [hm, or should I call it “bullet list explanation”?]:</p>
<ul>
<li><p>You can give -methods of typeclasses- default implementations. It allows instance writers to use the -implementation they would’ve used anyway- without actually bothering to write it, and at the same time they can use a better implementation when it’s available. For instance, the default implementation for <code>/=</code> is <code>x /= y = not (x == y)</code> (makes sense, doesn’t it), but the defition GHC uses for e.g. <code>Char</code> is</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb100-1"><a href="#cb100-1"></a>(<span class="dt">C</span><span class="op">#</span> c1) <span class="op">/=</span> (<span class="dt">C</span><span class="op">#</span> c2) <span class="ot">=</span> isTrue<span class="op">#</span> (c1 <span class="ot">`neChar#`</span> c2)</span></code></pre></div></li>
<li><p>Without this extension, the requirement for the default implementation is that it has the same type that the method has. You can’t do something like this:</p>
<div class="sourceCode" id="cb101"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb101-1"><a href="#cb101-1"></a><span class="kw">class</span> <span class="dt">Improve</span> a <span class="kw">where</span></span>
<span id="cb101-2"><a href="#cb101-2"></a><span class="ot">  improve ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb101-3"><a href="#cb101-3"></a>  improve <span class="dt">False</span> <span class="ot">=</span> <span class="dt">True</span></span></code></pre></div>
<p>even if you’re dead sure that <code>True</code> is better than <code>False</code>, because your default method has to work for all <code>a</code>s.</p></li>
<li><p>With <code>DefaultSignatures</code> enabled, however, you can choose one type (which can include constraints, etc.) for which you can provide the default method. For instance, lists of numbers:</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb102-1"><a href="#cb102-1"></a><span class="kw">class</span> <span class="dt">Improve</span> a <span class="kw">where</span></span>
<span id="cb102-2"><a href="#cb102-2"></a><span class="ot">  improve ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb102-3"><a href="#cb102-3"></a>  default<span class="ot"> improve ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb102-4"><a href="#cb102-4"></a>  improve <span class="ot">=</span> <span class="fu">map</span> (<span class="op">*</span><span class="dv">2</span>)</span></code></pre></div></li>
<li><p>The only trouble you might encounter is that when your type is so specific that it doesn’t even mention the type variables of the class, GHC will complain. This isn’t allowed:</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb103-1"><a href="#cb103-1"></a><span class="kw">class</span> <span class="dt">Improve</span> a <span class="kw">where</span></span>
<span id="cb103-2"><a href="#cb103-2"></a><span class="ot">  improve ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb103-3"><a href="#cb103-3"></a>  default<span class="ot"> improve ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb103-4"><a href="#cb103-4"></a>  improve _ <span class="ot">=</span> <span class="dt">True</span></span></code></pre></div>
<p>However, <em>this</em> is:</p>
<div class="sourceCode" id="cb104"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb104-1"><a href="#cb104-1"></a><span class="kw">class</span> <span class="dt">Improve</span> a <span class="kw">where</span></span>
<span id="cb104-2"><a href="#cb104-2"></a><span class="ot">  improve ::</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb104-3"><a href="#cb104-3"></a>  default<span class="ot"> improve ::</span> (a <span class="op">~</span> <span class="dt">Bool</span>) <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb104-4"><a href="#cb104-4"></a>  improve _ <span class="ot">=</span> <span class="dt">True</span></span></code></pre></div>
<p>(<code>~</code> is a type equality constraint. If <code>Num a</code> reads as “<code>a</code> is a number”, then <code>a ~ Bool</code> reads as “<code>a</code> is the same as <code>Bool</code>”.)</p></li>
</ul>
<p>Now you probably understand why there’s a <code>default</code> signature in the class definition – because the default method only works for <code>Traversable</code> types. You also understand why it’s</p>
<div class="sourceCode" id="cb105"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb105-1"><a href="#cb105-1"></a>default<span class="ot"> each ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Traversable</span> g, s <span class="op">~</span> g a, t <span class="op">~</span> g b)</span>
<span id="cb105-2"><a href="#cb105-2"></a>             <span class="ot">=&gt;</span> <span class="dt">LensLike</span> f s t a b</span></code></pre></div>
<p>and not</p>
<div class="sourceCode" id="cb106"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb106-1"><a href="#cb106-1"></a>default<span class="ot"> each ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Traversable</span> g)</span>
<span id="cb106-2"><a href="#cb106-2"></a>             <span class="ot">=&gt;</span> <span class="dt">LensLike</span> f (g a) (g b) a b</span></code></pre></div>
<p>– because the default signature has to mention all the type variables (<code>s</code>, <code>t</code>, <code>a</code> and <code>b</code> in our case).</p>
<h3 id="lenslike"><code>LensLike</code></h3>
<p>This is simply a convenient synonym:</p>
<div class="sourceCode" id="cb107"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb107-1"><a href="#cb107-1"></a><span class="kw">type</span> <span class="dt">LensLike</span> f s t a b <span class="ot">=</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> f t</span></code></pre></div>
<p>The interesting thing is that it doesn’t seem to be needed here. This declaration:</p>
<div class="sourceCode" id="cb108"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb108-1"><a href="#cb108-1"></a>default<span class="ot"> each ::</span> (<span class="dt">Applicative</span> f, <span class="dt">Traversable</span> g, s <span class="op">~</span> g a, t <span class="op">~</span> g b)</span>
<span id="cb108-2"><a href="#cb108-2"></a>             <span class="ot">=&gt;</span> <span class="dt">LensLike</span> f s t a b</span></code></pre></div>
<p>is supposed to be the same as:</p>
<div class="sourceCode" id="cb109"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb109-1"><a href="#cb109-1"></a>default<span class="ot"> each ::</span> (<span class="dt">Traversable</span> g, s <span class="op">~</span> g a, t <span class="op">~</span> g b)</span>
<span id="cb109-2"><a href="#cb109-2"></a>             <span class="ot">=&gt;</span> <span class="dt">Traversal</span> s t a b</span></code></pre></div>
<p>Why isn’t the latter used instead of the former?</p>
<p>Instead of spending a day thinking about it and testing various theories, I asked Edward Kmett on <code>#haskell-lens</code> (well, I asked <em>anybody,</em> but it was he who happened to answer):</p>
<pre><code>(06:57:55 AM) edwardk: because default signatures suck at dealing with
rank-2 types
(06:58:00 AM) edwardk: they just don&#39;t unify
(06:58:04 AM) edwardk: try it, it won&#39;t compile

...

(07:02:25 AM) edwardk: it may also be only on ghc &lt; 7.6 or so
(07:02:41 AM) edwardk: i&#39;d be happy to be wrong on this

...

(07:03:37 AM) edwardk: if that signature compiles on GHC 7.4 i&#39;d take a
patch to switch</code></pre>
<p>Ah, so there wasn’t any reason – the signature indeed compiled and the patch got accepted. Huzzah.</p>
<h3 id="inline"><code>INLINE</code></h3>
<p><code>{-# INLINE each #-}</code> means that the definition of <code>each</code> would be (roughly speaking) inserted directly into source code when compiling, instead of being called – this makes sense since in most cases it’s simply a call to another function. Of course, I still wonder how much of a benefit it is, but benchmarking lens is going to be the topic of a separate article.</p>
<h3 id="aa"><code>a~a'</code></h3>
<p>Here’s the code for the tuple instance again:</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb111-1"><a href="#cb111-1"></a><span class="kw">instance</span> (a<span class="op">~</span>a&#39;, b<span class="op">~</span>b&#39;) <span class="ot">=&gt;</span> <span class="dt">Each</span> (a,a&#39;) (b,b&#39;) a b <span class="kw">where</span></span>
<span id="cb111-2"><a href="#cb111-2"></a>  each f <span class="op">~</span>(a,b) <span class="ot">=</span> (,) <span class="op">&lt;$&gt;</span> f a <span class="op">&lt;*&gt;</span> f b</span></code></pre></div>
<p>The instance itself is easy to understand. However… There are 2 weird things here, and both involve a tilde (but these are <em>very</em> different tildes).</p>
<p>We already know that <code>~</code> means type equality. But why can’t we just say</p>
<div class="sourceCode" id="cb112"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb112-1"><a href="#cb112-1"></a><span class="kw">instance</span> <span class="dt">Each</span> (a, a) (b, b) a b <span class="kw">where</span></span></code></pre></div>
<p>instead? What’s the difference? Well, The difference is somewhat subtle, and it involves explaining how GHC works with instances.</p>
<ul>
<li><p>Each instance has a <em>context</em>. E.g.</p>
<div class="sourceCode" id="cb113"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb113-1"><a href="#cb113-1"></a><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> [a]</span></code></pre></div>
<p>has <code>Show a</code> as its context. Or, as described in Haskell report,</p>
<blockquote>
<p>The part before the <code>=&gt;</code> is the <em>context,</em> while the part after the <code>=&gt;</code> is the <em>head</em> of the instance declaration.</p>
</blockquote></li>
<li><p>When you’re doing something like <code>show x</code>, GHC looks at the type of <code>x</code> and tries to find the corresponding instance.</p></li>
<li><p>However, when searching GHC does <em>not</em> look at the contexts – only at the heads. For example, the following code wouldn’t even compile:</p>
<div class="sourceCode" id="cb114"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb114-1"><a href="#cb114-1"></a><span class="kw">class</span> <span class="dt">Foo</span> a <span class="kw">where</span></span>
<span id="cb114-2"><a href="#cb114-2"></a><span class="ot">  foo ::</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb114-3"><a href="#cb114-3"></a></span>
<span id="cb114-4"><a href="#cb114-4"></a><span class="kw">instance</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> <span class="dt">Foo</span> a <span class="kw">where</span></span>
<span id="cb114-5"><a href="#cb114-5"></a>  foo x <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb114-6"><a href="#cb114-6"></a></span>
<span id="cb114-7"><a href="#cb114-7"></a><span class="kw">instance</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Foo</span> a <span class="kw">where</span></span>
<span id="cb114-8"><a href="#cb114-8"></a>  foo x <span class="ot">=</span> <span class="dv">2</span></span></code></pre></div>
<p>because <code>instance Num a =&gt; Foo a</code> and <code>instance Show a =&gt; Foo a</code> are “the same”, as they only differ in their contexts.</p></li>
<li><p>If no instances overlap, GHC picks the one which matches and then checks whether the context is right. If the context isn’t “right”, GHC will complain – but it won’t look for other instances which could match.</p></li>
</ul>
<p>Now, if we write</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb115-1"><a href="#cb115-1"></a><span class="kw">instance</span> <span class="dt">Each</span> (a, a) (b, b) a b <span class="kw">where</span></span>
<span id="cb115-2"><a href="#cb115-2"></a>  each f <span class="op">~</span>(a,b) <span class="ot">=</span> (,) <span class="op">&lt;$&gt;</span> f a <span class="op">&lt;*&gt;</span> f b</span></code></pre></div>
<p>and accidentally try to use <code>each</code> on a tuple with different types, what would GHC complain about? Right, that it can’t find an instance:</p>
<div class="sourceCode" id="cb116"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb116-1"><a href="#cb116-1"></a><span class="op">&gt;</span> each <span class="dt">Just</span> (<span class="dt">False</span>, ())</span>
<span id="cb116-2"><a href="#cb116-2"></a></span>
<span id="cb116-3"><a href="#cb116-3"></a><span class="op">&lt;</span>interactive<span class="op">&gt;:</span></span>
<span id="cb116-4"><a href="#cb116-4"></a>    <span class="dt">No</span> <span class="kw">instance</span> for (<span class="dt">Each</span> (<span class="dt">Bool</span>, ()) t0 b0 b0)</span>
<span id="cb116-5"><a href="#cb116-5"></a>      arising from a use <span class="kw">of</span> ‘it’</span></code></pre></div>
<p>GHC doesn’t know that there isn’t an instance like <code>Each (Bool, ()) ...</code> defined anywhere and won’t <em>ever</em> be defined; thus, its complaint is entirely reasonable. However, GHC also (usually) does better with more information rather than less, and we know that if <code>each</code> is used on a tuple, its elements <em>have</em> to be equal.</p>
<p>To give GHC the same knowledge, first we show it an instance for <em>arbitrary</em> tuples (remember that GHC is context-blind at the moment):</p>
<div class="sourceCode" id="cb117"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb117-1"><a href="#cb117-1"></a><span class="kw">instance</span> (a <span class="op">~</span> a&#39;, b <span class="op">~</span> b&#39;) <span class="ot">=&gt;</span> <span class="dt">Each</span> (a, a&#39;) (b, b&#39;) a b</span></code></pre></div>
<p>GHC sees it and already commits to using it. Now it’s time to look at the context, and <em>there</em> we tell it that those tuples’ elements had to be of equal types. From now on GHC has no choice but to accept it – it can’t backtrack and look for another instance.</p>
<p>For comparison, here’s the error message GHC would actually give on <code>each Just (False, ())</code>:</p>
<div class="sourceCode" id="cb118"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb118-1"><a href="#cb118-1"></a><span class="op">&gt;</span> each <span class="dt">Just</span> (<span class="dt">False</span>, ())</span>
<span id="cb118-2"><a href="#cb118-2"></a></span>
<span id="cb118-3"><a href="#cb118-3"></a><span class="op">&lt;</span>interactive<span class="op">&gt;:</span></span>
<span id="cb118-4"><a href="#cb118-4"></a>    <span class="dt">Couldn&#39;t</span> match <span class="kw">type</span> ‘<span class="dt">Bool</span>’ with ‘()’</span>
<span id="cb118-5"><a href="#cb118-5"></a>    <span class="dt">In</span> the expression<span class="op">:</span> each <span class="dt">Just</span> (<span class="dt">False</span>, ())</span>
<span id="cb118-6"><a href="#cb118-6"></a>    <span class="dt">In</span> an equation for ‘it’<span class="op">:</span> it <span class="ot">=</span> each <span class="dt">Just</span> (<span class="dt">False</span>, ())</span></code></pre></div>
<p>Much better, isn’t it?</p>
<h3 id="ab"><code>~(a,b)</code></h3>
<p>Here’s the line again:</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb119-1"><a href="#cb119-1"></a>each f <span class="op">~</span>(a,b) <span class="ot">=</span> (,) <span class="op">&lt;$&gt;</span> f a <span class="op">&lt;*&gt;</span> f b</span></code></pre></div>
<p><code>~</code> here means a <em>lazy pattern</em>. Bullet list explanation:</p>
<ul>
<li><p>Haskell is lazy. If you don’t touch <code>undefined</code>, it won’t bite:</p>
<div class="sourceCode" id="cb120"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb120-1"><a href="#cb120-1"></a><span class="op">&gt;</span> (\x <span class="ot">-&gt;</span> <span class="dt">True</span>) <span class="fu">undefined</span></span>
<span id="cb120-2"><a href="#cb120-2"></a><span class="dt">True</span></span></code></pre></div></li>
<li><p>Sometimes, <del>unfortunately,</del> we have to evaluate things a bit. For instance, when determining whether a list is empty of not:</p>
<div class="sourceCode" id="cb121"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb121-1"><a href="#cb121-1"></a><span class="fu">null</span> [] <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb121-2"><a href="#cb121-2"></a><span class="fu">null</span> _  <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<p>Here <code>null</code> would have to look at the list <em>constructor</em> to make the decision. Therefore, <code>null undefined</code> is <code>undefined</code>, while e.g. <code>null (undefined:undefined)</code> is <code>False</code>.</p></li>
<li><p>Sometimes looking at the constructor isn’t really necessary. For instance, when the answer doesn’t depend on it:</p>
<div class="sourceCode" id="cb122"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb122-1"><a href="#cb122-1"></a><span class="ot">sillyVoid ::</span> [a] <span class="ot">-&gt;</span> ()</span>
<span id="cb122-2"><a href="#cb122-2"></a>sillyVoid []     <span class="ot">=</span> ()</span>
<span id="cb122-3"><a href="#cb122-3"></a>sillyVoid (x<span class="op">:</span>xs) <span class="ot">=</span> ()</span></code></pre></div>
<p>Is <code>sillyVoid</code> equal to <code>const ()</code>? No. Here’s where it fails:</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb123-1"><a href="#cb123-1"></a><span class="op">&gt;</span> <span class="fu">const</span> () <span class="fu">undefined</span></span>
<span id="cb123-2"><a href="#cb123-2"></a>()</span>
<span id="cb123-3"><a href="#cb123-3"></a></span>
<span id="cb123-4"><a href="#cb123-4"></a><span class="op">&gt;</span> sillyVoid <span class="fu">undefined</span></span>
<span id="cb123-5"><a href="#cb123-5"></a><span class="op">***</span> <span class="dt">Exception</span><span class="op">:</span> Prelude.undefined</span></code></pre></div></li>
<li><p>A less silly example is <code>each</code> (as well as <a href="http://hackage.haskell.org/package/base/docs/Control-Arrow.html#v:-42--42--42-"><code>***</code></a>, <code>first</code>, <code>second</code>, <a href="http://hackage.haskell.org/package/base/docs/Data-Bifunctor.html#v:bimap"><code>bimap</code></a> and other tuple-related functions). Let’s say we set the first element of a tuple to <code>False</code>, and the second to <code>True</code>. Do you expect the result to always be <code>(False, True)</code>?</p>
<div class="sourceCode" id="cb124"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb124-1"><a href="#cb124-1"></a><span class="op">&gt;</span> first (<span class="fu">const</span> <span class="dt">False</span>) <span class="op">$</span> second (<span class="fu">const</span> <span class="dt">True</span>) <span class="op">$</span><span class="ot"> undefined ::</span> (<span class="dt">Bool</span>, <span class="dt">Bool</span>)</span>
<span id="cb124-2"><a href="#cb124-2"></a>(<span class="dt">False</span>, <span class="dt">True</span>)</span></code></pre></div>
<p>Nice. What if we use our own function to do it?</p>
<div class="sourceCode" id="cb125"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb125-1"><a href="#cb125-1"></a><span class="op">&gt;</span> <span class="kw">let</span> setFT (x, y) <span class="ot">=</span> (<span class="dt">False</span>, <span class="dt">True</span>)</span>
<span id="cb125-2"><a href="#cb125-2"></a></span>
<span id="cb125-3"><a href="#cb125-3"></a><span class="op">&gt;</span> setFT (<span class="fu">undefined</span><span class="ot"> ::</span> (<span class="dt">Bool</span>, <span class="dt">Bool</span>))</span>
<span id="cb125-4"><a href="#cb125-4"></a><span class="op">***</span> <span class="dt">Exception</span><span class="op">:</span> Prelude.undefined</span></code></pre></div>
<p>Expected, but still isn’t nice.</p></li>
<li><p><code>~</code> defers looking at the constructor until it’s really needed. These pieces of code are equivalent:</p>
<div class="sourceCode" id="cb126"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb126-1"><a href="#cb126-1"></a>f <span class="op">~</span>(x, y) <span class="ot">=</span> <span class="op">...</span> x <span class="op">...</span> y</span></code></pre></div>
<p>and</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb127-1"><a href="#cb127-1"></a>f pair <span class="ot">=</span> <span class="op">...</span> (<span class="fu">fst</span> pair) <span class="op">...</span> (<span class="fu">snd</span> pair)</span></code></pre></div></li>
<li><p>So, if we want <code>over each (const ())</code> to always be the same as <code>const ((), ())</code>, we need that <code>~</code> there.</p></li>
<li><p>These are also called <em>irrefutable</em> patterns, by the way. You can read more in the <a href="http://en.wikibooks.org/wiki/Haskell/Laziness#Lazy_pattern_matching">Haskell Wikibook</a></p></li>
<li><p>Finally, keep in mind that not all tuple functions work like this. For instance, the <code>Monoid</code> instance for tuples doesn’t – <code>((), ()) &lt;&gt; undefined</code> should be <code>((), ())</code> “in theory”, but in reality it’s <code>undefined</code>. This <a href="http://osdir.com/ml/libraries@haskell.org/2013-08/msg00120.html">has to do something with space leaks</a>.</p></li>
</ul>
<p>Okay, enough about <code>Each</code>. 2 more simple traversals and time for another recap.</p>
<h2 id="head-_last-first-and-last-elements"><code>_head</code>, <code>_last</code> = first and last elements</h2>
<p><a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Cons.html#v:_head"><code>_head</code></a> and <a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Cons.html#v:_last"><code>_last</code></a> give access to the first and last element of a container (a list, vector, etc.). For simplicity, I’ll only define <code>_head</code> for lists:</p>
<div class="sourceCode" id="cb128"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb128-1"><a href="#cb128-1"></a><span class="ot">_head ::</span> <span class="dt">Traversal&#39;</span> [a] a</span>
<span id="cb128-2"><a href="#cb128-2"></a>_head f []     <span class="ot">=</span> <span class="fu">pure</span> []</span>
<span id="cb128-3"><a href="#cb128-3"></a>_head f (x<span class="op">:</span>xs) <span class="ot">=</span> (<span class="op">:</span>) <span class="op">&lt;$&gt;</span> f x <span class="op">&lt;*&gt;</span> <span class="fu">pure</span> xs</span></code></pre></div>
<p>You might be wondering: “defining <code>_head</code> for lists is easy, why wouldn’t he show how to define it for <code>Text</code> instead?”. Indeed, initially I wanted to define it for <code>Text</code> in a more efficient way than unconsing-and-consing, and was starting to feel bad when I couldn’t think of a way to do it – but then I realised that it’s impossible. Imagine the functor in question being <code>[]</code> – how can you construct many <code>Text</code>s, each with a different first character, without actually duplicating the character array? (Yep, I know that <code>Text</code> can <a href="https://hackage.haskell.org/package/text/docs/Data-Text-Lazy-Internal.html#t:Text">consist of chunks</a> – let’s assume we’re talking about strings shorter than one chunk.)</p>
<h2 id="recap-1">Recap</h2>
<ul>
<li><p>A lens focuses on one value; a traversal – on many (may be 0 as well).</p></li>
<li><p>Traversals are lenses with <code>Applicative</code> instead of <code>Functor</code>:</p>
<div class="sourceCode" id="cb129"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb129-1"><a href="#cb129-1"></a><span class="kw">type</span> <span class="dt">Traversal</span> s t a b <span class="ot">=</span> <span class="dt">Applicative</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> f t</span></code></pre></div></li>
<li><p>In order to let <code>view</code>, <code>over</code>, <code>set</code>, etc. work with both lenses and traversals, their types are specialised to <code>Getting</code> and <code>Setting</code>:</p>
<div class="sourceCode" id="cb130"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb130-1"><a href="#cb130-1"></a><span class="co">-- Mentally simplified to “(a -&gt; r) -&gt; s -&gt; r”.</span></span>
<span id="cb130-2"><a href="#cb130-2"></a><span class="kw">type</span> <span class="dt">Getting</span> r s a <span class="ot">=</span> (a <span class="ot">-&gt;</span> <span class="dt">Const</span> r a) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Const</span> r s</span>
<span id="cb130-3"><a href="#cb130-3"></a></span>
<span id="cb130-4"><a href="#cb130-4"></a><span class="co">-- Mentally simplified to “(a -&gt; b) -&gt; s -&gt; r”.</span></span>
<span id="cb130-5"><a href="#cb130-5"></a><span class="kw">type</span> <span class="dt">Setting</span> s t a b <span class="ot">=</span> (a <span class="ot">-&gt;</span> <span class="dt">Identity</span> b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> <span class="dt">Identity</span> t</span>
<span id="cb130-6"><a href="#cb130-6"></a></span>
<span id="cb130-7"><a href="#cb130-7"></a><span class="ot">view ::</span> <span class="dt">Getting</span> a s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a</span>
<span id="cb130-8"><a href="#cb130-8"></a><span class="ot">over ::</span> <span class="dt">Setting</span> s t a b <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> t</span>
<span id="cb130-9"><a href="#cb130-9"></a><span class="ot">set  ::</span> <span class="dt">Setting</span> s t a b <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> t</span></code></pre></div></li>
<li><p>The <code>Applicative</code> instance for <code>Const</code> uses monoids to combine results, which means that by simply varying the monoid you can</p>
<ul>
<li><p>get all traversed values (monoid: <code>Endo []</code>, function: <code>toListOf</code>)</p></li>
<li><p>get the first value (monoid: <code>First</code>, function: <code>preview</code>)</p></li>
<li><p>check for value (monoid: <code>Any</code>, function: <code>has</code>)</p></li>
<li><p>find the sum of traversed values (monoid: <code>Sum</code>)</p></li>
<li><p>find the product of traversed values (monoid: <code>Product</code>)</p></li>
<li><p>and so on (I haven’t actually mentioned the last 2 in text, but hearing “<code>Sum</code>” and “<code>Product</code>” should be enough to figure it out)</p></li>
</ul></li>
<li><p>There are various predefined traversals, such as <code>each</code>, <code>_head</code> and <code>_last</code>. (Another few easy ones are <a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#v:both"><code>both</code></a>, <a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Cons.html#v:_tail"><code>_tail</code></a> and <a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Cons.html#v:_init"><code>_init</code></a>. Other ones use scary indexed stuff and <a href="http://hackage.haskell.org/package/lens/docs/Control-Lens-Traversal.html#t:Bazaar"><code>Bazaar</code></a>s and who-knows-what-else, so we won’t touch them yet.)</p></li>
</ul>
<p>Bonus stuff:</p>
<ul>
<li><p>Difference lists are easy to implement and give you O(1) appends (but O(N) <code>head</code>).</p></li>
<li><p>With default signatures there are more situations when you can add a default implementation to a method.</p></li>
<li><p><code>#haskell-lens</code> has all the answers.</p></li>
<li><p>Type equality constraints (<code>~</code>) give you better error messages (and can be generally useful).</p></li>
<li><p>GHC doesn’t take constraints into consideration when searching for a matching instance.</p></li>
<li><p>Irrefutable (“lazy”) patterns let you do lazy matching on values; however, it’s rarely useful and you can always replace them by getters (e.g. <code>~(x, y)</code> by <code>fst</code> and <code>snd</code>).</p></li>
</ul>
<h1 id="appendix-operators">Appendix: operators</h1>
<p>There are many operators in lens – 124 in <code>Control.Lens</code> at the moment of writing (there are some other operators which aren’t exported by this module). You don’t have to use them all, but since people generally have different ideas about which operators they don’t and do have to use… Anyway, here’s the first bunch.</p>
<ul>
<li><p><code>view</code> is <code>^.</code> (with arguments flipped):</p>
<div class="sourceCode" id="cb131"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb131-1"><a href="#cb131-1"></a><span class="op">&gt;</span> (<span class="dv">1</span>, <span class="dv">2</span>) <span class="op">^.</span> _1</span>
<span id="cb131-2"><a href="#cb131-2"></a><span class="dv">1</span></span></code></pre></div></li>
<li><p><code>over</code> is <code>%~</code>:</p>
<div class="sourceCode" id="cb132"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb132-1"><a href="#cb132-1"></a><span class="op">&gt;</span> (_1 <span class="op">%~</span> <span class="fu">negate</span>) (<span class="dv">1</span>, <span class="dv">2</span>)</span>
<span id="cb132-2"><a href="#cb132-2"></a>(<span class="op">-</span><span class="dv">1</span>, <span class="dv">2</span>)</span></code></pre></div></li>
<li><p><code>&amp;</code> is backwards function application:</p>
<div class="sourceCode" id="cb133"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb133-1"><a href="#cb133-1"></a><span class="op">&gt;</span> <span class="op">:</span>t _1 <span class="op">%~</span> <span class="fu">negate</span></span>
<span id="cb133-2"><a href="#cb133-2"></a>_1 <span class="op">%~</span><span class="ot"> negate ::</span> <span class="dt">Num</span> a <span class="ot">=&gt;</span> (a, x) <span class="ot">-&gt;</span> (a, x)</span>
<span id="cb133-3"><a href="#cb133-3"></a></span>
<span id="cb133-4"><a href="#cb133-4"></a><span class="op">&gt;</span> (<span class="dv">1</span>, <span class="dv">2</span>) <span class="op">&amp;</span> _1 <span class="op">%~</span> <span class="fu">negate</span></span>
<span id="cb133-5"><a href="#cb133-5"></a>(<span class="op">-</span><span class="dv">1</span>, <span class="dv">2</span>)</span></code></pre></div>
<p>It lets you create nice-looking chains:</p>
<div class="sourceCode" id="cb134"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb134-1"><a href="#cb134-1"></a>blah <span class="op">&amp;</span> somePart  <span class="op">%~</span> f</span>
<span id="cb134-2"><a href="#cb134-2"></a>     <span class="op">&amp;</span> otherPart <span class="op">%~</span> g</span>
<span id="cb134-3"><a href="#cb134-3"></a>     <span class="op">&amp;</span> <span class="op">...</span></span></code></pre></div></li>
<li><p><code>set</code> is <code>.~</code>:</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb135-1"><a href="#cb135-1"></a><span class="op">&gt;</span> (<span class="dv">1</span>, <span class="dv">2</span>) <span class="op">&amp;</span> _1 <span class="op">.~</span> <span class="dv">88</span></span>
<span id="cb135-2"><a href="#cb135-2"></a>(<span class="dv">88</span>, <span class="dv">2</span>)</span></code></pre></div></li>
<li><p><code>&lt;%~</code> is <code>over</code> which also returns the new value:</p>
<div class="sourceCode" id="cb136"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb136-1"><a href="#cb136-1"></a><span class="op">&gt;</span> [<span class="dv">0</span><span class="op">..</span><span class="dv">10</span>] <span class="op">&amp;</span> ix <span class="dv">10</span> <span class="op">&lt;%~</span> <span class="fu">negate</span></span>
<span id="cb136-2"><a href="#cb136-2"></a>(<span class="op">-</span><span class="dv">10</span>, [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="op">-</span><span class="dv">10</span>])</span></code></pre></div>
<p>As there’s no single “new” value in case of a traversal, you can’t use <code>&lt;%~</code> on traversals (well, or you can but you’ll stumble upon the <code>Monoid</code> problem).</p></li>
<li><p><code>&lt;&lt;%~</code> is like <code>&lt;%~</code>, but it returns the <em>old</em> value:</p>
<div class="sourceCode" id="cb137"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb137-1"><a href="#cb137-1"></a><span class="op">&gt;</span> [<span class="dv">0</span><span class="op">..</span><span class="dv">10</span>] <span class="op">&amp;</span> ix <span class="dv">10</span> <span class="op">&lt;&lt;%~</span> <span class="fu">negate</span></span>
<span id="cb137-2"><a href="#cb137-2"></a>(<span class="dv">10</span>, [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">8</span>,<span class="dv">9</span>,<span class="op">-</span><span class="dv">10</span>])</span></code></pre></div></li>
<li><p>Instead of <code>%</code>, you can put in <code>+</code>, <code>-</code>, <code>*</code>, <code>//</code>, <code>^</code>, <code>||</code>, <code>&lt;&gt;</code> and so on to get specialised versions:</p>
<div class="sourceCode" id="cb138"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb138-1"><a href="#cb138-1"></a><span class="op">&gt;</span> <span class="co">-- Multiply by 2.</span></span>
<span id="cb138-2"><a href="#cb138-2"></a><span class="op">&gt;</span> [<span class="dv">0</span><span class="op">..</span><span class="dv">10</span>] <span class="op">&amp;</span> each <span class="op">*~</span> <span class="dv">2</span>  <span class="co">-- Multiply by 2.</span></span>
<span id="cb138-3"><a href="#cb138-3"></a>[<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">6</span>, <span class="dv">8</span>, <span class="dv">10</span>, <span class="dv">12</span>, <span class="dv">14</span>, <span class="dv">16</span>, <span class="dv">18</span>, <span class="dv">20</span>]</span>
<span id="cb138-4"><a href="#cb138-4"></a></span>
<span id="cb138-5"><a href="#cb138-5"></a><span class="op">&gt;</span> <span class="co">-- Raise to the 3rd power and return the old value.</span></span>
<span id="cb138-6"><a href="#cb138-6"></a><span class="op">&gt;</span> [<span class="dv">0</span><span class="op">..</span><span class="dv">10</span>] <span class="op">&amp;</span> ix <span class="dv">10</span> <span class="op">&lt;&lt;^~</span> <span class="dv">3</span></span>
<span id="cb138-7"><a href="#cb138-7"></a>(<span class="dv">10</span>, [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">9</span>, <span class="dv">1000</span>])</span></code></pre></div>
<p>This already gives you ~30 operators.</p>
<p>(…Please don’t use most of them. Honestly, stuff like <code>&lt;&lt;**~ x</code> is scary, and if it’s not scary for you, it’ll most likely be scary for people who would have to read your code.) Could you perhaps consider using e.g. <code>&lt;&lt;%~ (** x)</code> instead? Thanks.)</p></li>
<li><p><code>toListOf</code> is <code>^..</code>:</p>
<div class="sourceCode" id="cb139"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb139-1"><a href="#cb139-1"></a><span class="op">&gt;</span> (<span class="dv">1</span>, <span class="dv">2</span>) <span class="op">^..</span> each</span>
<span id="cb139-2"><a href="#cb139-2"></a>[<span class="dv">1</span>, <span class="dv">2</span>]               <span class="co">-- `each` looks at all elements.</span></span>
<span id="cb139-3"><a href="#cb139-3"></a></span>
<span id="cb139-4"><a href="#cb139-4"></a><span class="op">&gt;</span> [] <span class="op">^..</span> _head</span>
<span id="cb139-5"><a href="#cb139-5"></a>[]                   <span class="co">-- `_head` looks at the first element, if it exists.</span></span>
<span id="cb139-6"><a href="#cb139-6"></a></span>
<span id="cb139-7"><a href="#cb139-7"></a><span class="op">&gt;</span> [<span class="dv">0</span><span class="op">..</span><span class="dv">10</span>] <span class="op">^..</span> _head</span>
<span id="cb139-8"><a href="#cb139-8"></a>[<span class="dv">0</span>]                  <span class="co">-- `[0..10]` has only 1 first element (surprise!).</span></span></code></pre></div>
<p>It’s simple to remember: <code>^.</code> (“viewing”) + <code>..</code> (“something list-y”).</p></li>
<li><p><code>preview</code> is <code>^?</code>:</p>
<div class="sourceCode" id="cb140"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb140-1"><a href="#cb140-1"></a><span class="op">&gt;</span> [<span class="dv">0</span><span class="op">..</span><span class="dv">10</span>] <span class="op">^?</span> _head</span>
<span id="cb140-2"><a href="#cb140-2"></a><span class="dt">Just</span> <span class="dv">0</span></span>
<span id="cb140-3"><a href="#cb140-3"></a></span>
<span id="cb140-4"><a href="#cb140-4"></a><span class="op">&gt;</span> [<span class="dv">0</span><span class="op">..</span><span class="dv">10</span>] <span class="op">^?</span> each</span>
<span id="cb140-5"><a href="#cb140-5"></a><span class="dt">Just</span> <span class="dv">0</span></span></code></pre></div></li>
</ul>
<p>If you’re implementing everything we’ve covered in a separate module (i.e. creating your own mini lens library), don’t forget to add fixity declarations for these operators. You can take them from the source of lens, or find out using GHCi:</p>
<div class="sourceCode" id="cb141"><pre class="sourceCode haskell repl"><code class="sourceCode haskell"><span id="cb141-1"><a href="#cb141-1"></a><span class="op">&gt;</span> <span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Control.Lens</span> <span class="kw">as</span> <span class="dt">L</span></span>
<span id="cb141-2"><a href="#cb141-2"></a></span>
<span id="cb141-3"><a href="#cb141-3"></a><span class="op">&gt;</span> <span class="op">:</span>i <span class="op">L.&amp;</span></span>
<span id="cb141-4"><a href="#cb141-4"></a>(<span class="op">L.&amp;</span>)<span class="ot"> ::</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b 	<span class="co">-- Defined in ‘Control.Lens.Lens’</span></span>
<span id="cb141-5"><a href="#cb141-5"></a><span class="kw">infixl</span> <span class="dv">1</span> <span class="op">L.&amp;</span></span>
<span id="cb141-6"><a href="#cb141-6"></a></span>
<span id="cb141-7"><a href="#cb141-7"></a><span class="op">&gt;</span> <span class="op">:</span>i <span class="op">L.^?</span></span>
<span id="cb141-8"><a href="#cb141-8"></a>(<span class="op">L.^?</span>)<span class="ot"> ::</span> s <span class="ot">-&gt;</span> <span class="dt">L.Getting</span> (<span class="dt">First</span> a) s a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</span>
<span id="cb141-9"><a href="#cb141-9"></a>  	<span class="co">-- Defined in ‘Control.Lens.Fold’</span></span>
<span id="cb141-10"><a href="#cb141-10"></a><span class="kw">infixl</span> <span class="dv">8</span> <span class="op">L.^?</span></span></code></pre></div>
<p>A fixity declaration just describes</p>
<ul>
<li><p>the priority of the operator, from 0 to 9; 0 means “is applied last” (<code>$</code> has this priority) and 9 means “is applied first” (that’s <code>.</code>, for instance)</p></li>
<li><p>the fixity of the operator, which can be <code>infixr</code>, <code>infixl</code>, or <code>infix</code>; if several operators have equal priority and they are all <code>infixr</code> or <code>infixl</code>, the rightmost/leftmost operator would be applied first; if there’s an <code>infix</code> operator in the mix, it’s an error</p></li>
</ul>
<p>To add a fixity declaration, just write it before or after the operator:</p>
<div class="sourceCode" id="cb142"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb142-1"><a href="#cb142-1"></a>(<span class="op">!!!</span>) <span class="ot">=</span> <span class="fu">undefined</span></span>
<span id="cb142-2"><a href="#cb142-2"></a></span>
<span id="cb142-3"><a href="#cb142-3"></a><span class="kw">infixl</span> <span class="dv">4</span> <span class="op">!!!</span></span></code></pre></div>
<p>By the way, you can give fixity declarations to functions as well (which will affect their usage in backticks) – for instance, <code>elem</code> and <code>mod</code> are <code>infix 4</code> and <code>infixl 7</code> respectively.</p>
<h1 id="to-be-continued">To be continued</h1>
<p>The next part will be about getters, setters and folds. I’ll also describe <code>Lens</code>/<code>Traversal</code> laws, why our <code>ix</code> isn’t a lens and <code>_all'</code> isn’t a traversal [I wonder, were those of you -who know about lens laws- already planning to write caustic comments on this topic?], and how lenses compose.</p>
<p>Oh, and the answer to the bonus points exercise is this:</p>
<div class="sourceCode" id="cb143"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb143-1"><a href="#cb143-1"></a><span class="ot">(&lt;%~) ::</span> <span class="dt">Lens</span> s t a b <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (b, t)</span>
<span id="cb143-2"><a href="#cb143-2"></a>(<span class="op">&lt;%~</span>) l f s <span class="ot">=</span> l ((,) <span class="op">&lt;$&gt;</span> f <span class="op">&lt;*&gt;</span> f) s</span></code></pre></div>
<p>And here’s an even better-looking solution if you are willing to use <a href="http://hackage.haskell.org/package/base/docs/Control-Arrow.html#v:-38--38--38-"><code>&amp;&amp;&amp;</code></a>:</p>
<div class="sourceCode" id="cb144"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb144-1"><a href="#cb144-1"></a>(<span class="op">&lt;%~</span>) l f <span class="ot">=</span> l (f <span class="op">&amp;&amp;&amp;</span> f)</span></code></pre></div>
<p>And here’s another one that I got by email after the post was published:</p>
<div class="sourceCode" id="cb145"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb145-1"><a href="#cb145-1"></a>(<span class="op">&lt;%~</span>) l f <span class="ot">=</span> l (join (,) <span class="op">.</span> f)</span></code></pre></div>
<p>It’s also faster because it computes the value-you-are-setting only once. All previous variants were doing this:</p>
<div class="sourceCode" id="cb146"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb146-1"><a href="#cb146-1"></a>(<span class="op">&lt;%~</span>) l f <span class="ot">=</span> l (\x <span class="ot">-&gt;</span> (f x, f x))</span></code></pre></div>
<p>But the right thing to do is one of these:</p>
<div class="sourceCode" id="cb147"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb147-1"><a href="#cb147-1"></a>(<span class="op">&lt;%~</span>) l f <span class="ot">=</span> l (\x <span class="ot">-&gt;</span> <span class="kw">let</span> fx <span class="ot">=</span> f x <span class="kw">in</span> (fx, fx))</span>
<span id="cb147-2"><a href="#cb147-2"></a></span>
<span id="cb147-3"><a href="#cb147-3"></a>(<span class="op">&lt;%~</span>) l f <span class="ot">=</span> l <span class="op">$</span> (\t <span class="ot">-&gt;</span> (t, t)) <span class="op">.</span> f</span></code></pre></div>
<p>Okay, and while I’m at it, here’s a nice one for <code>&lt;&lt;%~</code>:</p>
<div class="sourceCode" id="cb148"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb148-1"><a href="#cb148-1"></a><span class="ot">(&lt;&lt;%~) ::</span> <span class="dt">Lens</span> s t a b <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (a, t)</span>
<span id="cb148-2"><a href="#cb148-2"></a>(<span class="op">&lt;&lt;%~</span>) l f <span class="ot">=</span> l ((,) <span class="op">&lt;*&gt;</span> f)</span>
<span id="cb148-3"><a href="#cb148-3"></a></span>
<span id="cb148-4"><a href="#cb148-4"></a><span class="co">-- equivalent to ((,) &lt;$&gt; id &lt;*&gt; f)</span></span>
<span id="cb148-5"><a href="#cb148-5"></a><span class="co">-- equivalent to (\x -&gt; (x, f x))</span></span></code></pre></div>
<p>The answers to all other exercises are <a href="http://lpaste.net/6450842794700308480">here</a>.</p>
<h1 id="p.s.">P.S.</h1>
<p><a href="https://hackage.haskell.org/package/lens">lens</a> is a huge package, so I took a chunk out of it and put into a separate library – <a href="https://github.com/monadfix/microlens">microlens</a>. It has no dependencies, it compiles in about 4 seconds, and in many cases it’s a good replacement for lens (i.e. if you want to use the power of lenses in your library and don’t like heavy dependencies).</p>
<p>Don’t use microlens for this series, tho; many of things I’m covering here are lens-specific (isomorphisms, prisms, indexed traversals, etc).</p>
</article>


<div id="series">
      <span class="grey"><a href="/#lens-over-tea">&lt;&lt;&lt;</a></span>
  
  <a href="/#lens-over-tea">“lens over tea”</a>

      <a href="/lens-over-tea-2">&gt;&gt;&gt;</a>
  </div>

</div>

<div id="monadfix" class="blue-links">
  <h3>I'm doing software consulting!</h3>
  <p>
    Nowadays I'm running a functional programming consultancy at
    <a href="https://monadfix.com">Monadfix</a>. We have experts in Haskell
    and Agda. We are looking for more clients and more consultants!
  </p>
</div>

<div id="disqus_thread"></div>
<script>
var disqus_config = function () {
this.page.url = "https://artyom.me/lens-over-tea-1";
this.page.identifier = "lens-over-tea-1";
};
(function() { // DON'T EDIT BELOW THIS LINE
var d = document, s = d.createElement('script');
s.src = '//artyomkazak.disqus.com/embed.js';
s.setAttribute('data-timestamp', +new Date());
(d.head || d.body).appendChild(s);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>

<div id="footer" class="blue-links">
<a href="https://github.com/neongreen/artyom.me/blob/master/posts/lens-over-tea-1.md">view source</a>—<a href="mailto:artyom@artyom.me?subject=Comment on lens-over-tea-1">comment by email</a>
</div>

</div>

<script>
document.body.innerHTML = document.body.innerHTML.replace(/‾/g, "<span style='text-decoration: overline'> </span>");
</script>

</body>
</html>
